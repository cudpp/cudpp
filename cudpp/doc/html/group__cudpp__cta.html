<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CUDPP: CUDPP CTA-Level API</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CUDPP CTA-Level API</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_traits.html">ScanTraits&lt; T, oper, backward, exclusive, multiRow, sums, fullBlock &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template class containing compile-time parameters to the scan functions.  <a href="class_scan_traits.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_segmented_scan_traits.html">SegmentedScanTraits&lt; T, oper, backward, exclusivity, doShiftFlags, fullBlock, sums, sm12OrBetter &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template class containing compile-time parameters to the segmented scan functions.  <a href="class_segmented_scan_traits.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Radix Sort Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="cudpp_cta::uint" ref="g91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;bool doFlip&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ uint&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g05ad3c672e73b35a200893881f3d1cd2">floatFlip</a> (uint f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flips bits of single-precision floating-point number (parameterized by doFlip).  <a href="#g05ad3c672e73b35a200893881f3d1cd2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;bool doFlip&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ uint&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g3cf28e5904a54e10af2d1c3fea729a59">floatUnflip</a> (uint f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverses bit-flip of single-precision floating-point number (parameterized by doFlip).  <a href="#g3cf28e5904a54e10af2d1c3fea729a59"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T , int maxlevel&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gd65926bbfd7939404fa697e7b23a2286">scanwarp</a> (T val, T *sData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans one warp quickly, optimized for 32-element warps, using shared memory.  <a href="#gd65926bbfd7939404fa697e7b23a2286"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ uint4&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gbfa515588187af6524cbfd4d76fd16c5">scan4</a> (uint4 idata)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scans 4*CTA_SIZE unsigned ints in a block.  <a href="#gbfa515588187af6524cbfd4d76fd16c5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;int ctasize&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ uint4&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gc598a1e6647cdfdb14ab24d0411ad1f5">rank4</a> (uint4 preds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes output position for each thread given predicate; trues come first then falses.  <a href="#gc598a1e6647cdfdb14ab24d0411ad1f5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;uint nbits, uint startbit&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gd6197a166da7197ec317c4373a8ff232">radixSortBlock</a> (uint4 &amp;key, uint4 &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts one block.  <a href="#gd6197a166da7197ec317c4373a8ff232"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;uint nbits, uint startbit&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g8927705927517481e2115784a2bf1876">radixSortBlockKeysOnly</a> (uint4 &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts one block. Key-only version.  <a href="#g8927705927517481e2115784a2bf1876"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Rand Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g13c90ad7137a333b8ad2d3ccbb447fef">swizzleShift</a> (uint4 *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.  <a href="#g13c90ad7137a333b8ad2d3ccbb447fef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g6139c8e2423bd271815ffb6feb572080">leftRotate</a> (unsigned int x, unsigned int n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotates the bits in <em>x</em> over by <em>n</em> bits.  <a href="#g6139c8e2423bd271815ffb6feb572080"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gf6d7ad89002d2bc4ea5dfda74c5044c0">F</a> (unsigned int x, unsigned int y, unsigned int z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The F scrambling function.  <a href="#gf6d7ad89002d2bc4ea5dfda74c5044c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g903661679dd9f375fc6cfbcb285f39b1">G</a> (unsigned int x, unsigned int y, unsigned int z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The G scrambling function.  <a href="#g903661679dd9f375fc6cfbcb285f39b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g573bcce88a259368f3c2025371bdf656">H</a> (unsigned int x, unsigned int y, unsigned int z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The H scrambling function.  <a href="#g573bcce88a259368f3c2025371bdf656"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gf2de48c1f68ee34f9943390241961fb2">I</a> (unsigned int x, unsigned int y, unsigned int z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The I scrambling function.  <a href="#gf2de48c1f68ee34f9943390241961fb2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g441b30dd5f34b0f92a826e2835a2924b">FF</a> (uint4 *td, int i, uint4 *Fr, float p, unsigned int *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The FF scrambling function.  <a href="#g441b30dd5f34b0f92a826e2835a2924b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g45ddf2b6f6e2a98ce150f592ba32d3fa">GG</a> (uint4 *td, int i, uint4 *Gr, float p, unsigned int *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The GG scrambling function.  <a href="#g45ddf2b6f6e2a98ce150f592ba32d3fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gfa4aefc8ed889545483f0686a5da016f">HH</a> (uint4 *td, int i, uint4 *Hr, float p, unsigned int *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The HH scrambling function.  <a href="#gfa4aefc8ed889545483f0686a5da016f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g19d04cb1fa018499b6f5ef3a873bdd50">II</a> (uint4 *td, int i, uint4 *Ir, float p, unsigned int *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The II scrambling function.  <a href="#g19d04cb1fa018499b6f5ef3a873bdd50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gd815ed3373fd7ed8be004190d392a429">setupInput</a> (unsigned int *input, unsigned int seed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the <em>input</em> array using information of <em>seed</em>, and <em>threadIdx</em>.  <a href="#gd815ed3373fd7ed8be004190d392a429"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Scan Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gc07542291db720d7382ab8c261c0f274">loadSharedChunkFromMem4</a> (T *s_out, T threadScan0[4], T threadScan1[4], const T *d_in, int numElements, int iDataOffset, int &amp;ai, int &amp;bi, int &amp;aiDev, int &amp;biDev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles loading input s_data from global memory to shared memory (vec4 version).  <a href="#gc07542291db720d7382ab8c261c0f274"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g57d07bd79aea5f056c2c0fbfc604872a">storeSharedChunkToMem4</a> (T *d_out, T threadScan0[4], T threadScan1[4], T *s_in, int numElements, int oDataOffset, int ai, int bi, int aiDev, int biDev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles storing result s_data from shared memory to global memory (vec4 version).  <a href="#g57d07bd79aea5f056c2c0fbfc604872a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T , class traits , int maxlevel&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g2e02e951efac2a6fba038cd102ef0415">warpscan</a> (T val, volatile T *s_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scan all warps of a CTA without synchronization.  <a href="#g2e02e951efac2a6fba038cd102ef0415"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g163e1d81b5e290f00dcdf77060bc5c40">scanWarps</a> (T x, T y, T *s_data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a full CTA scan using the warp-scan algorithm.  <a href="#g163e1d81b5e290f00dcdf77060bc5c40"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gc39bd4553f352fb03361a56b17be04ee">scanCTA</a> (T *s_data, T *d_blockSums, unsigned int blockSumIndex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CTA-level scan routine; scans s_data in shared memory in each thread block.  <a href="#gc39bd4553f352fb03361a56b17be04ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gcdb347964aea5ead8e422917e4e5a876"></a><!-- doxytag: member="cudpp_cta::__EMUSYNC" ref="gcdb347964aea5ead8e422917e4e5a876" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gcdb347964aea5ead8e422917e4e5a876">__EMUSYNC</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to insert necessary __syncthreads() in device emulation mode. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gb75dfd738e3beffebf497fbf120019fb">DISALLOW_LOADSTORE_OVERLAP</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td colspan="2"><br><h2>Segmented scan Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T , typename traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gf417327731b668f89a1a8a32ae715e63">loadForSegmentedScanSharedChunkFromMem4</a> (T *s_odata, T threadScan0[4], T threadScan1[4], unsigned int &amp;threadFlag, unsigned int *s_oflags, unsigned int *s_oindices, const T *d_idata, const unsigned int *d_iflags, int numElements, int iDataOffset, int &amp;ai, int &amp;bi, int &amp;aiDev, int &amp;biDev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles loading input s_data from global memory to shared memory (vec4 version).  <a href="#gf417327731b668f89a1a8a32ae715e63"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#gb970a2f1d36591efe8376d8a1eaf2964">storeForSegmentedScanSharedChunkToMem4</a> (T *d_odata, T threadScan0[4], T threadScan1[4], unsigned int threadFlag, T *s_idata, unsigned int numElements, int oDataOffset, int ai, int bi, int aiDev, int biDev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles storing result s_data from shared memory to global memory (vec4 version).  <a href="#gb970a2f1d36591efe8376d8a1eaf2964"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gde4eab4e53da4eb280fabcb4755d124b"></a><!-- doxytag: member="cudpp_cta::reduceCTA" ref="gde4eab4e53da4eb280fabcb4755d124b" args="(T *s_data)" -->
template&lt;class T , class traits , unsigned int blockSize&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>reduceCTA</b> (T *s_data)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc76cb191574c4814932e7eaa832332f4"></a><!-- doxytag: member="cudpp_cta::warpSegScan" ref="gc76cb191574c4814932e7eaa832332f4" args="(T val, unsigned int flag, volatile T *s_data, volatile unsigned int *s_flags, T &amp;oVal, unsigned int &amp;oFlag)" -->
template&lt;class T , class traits , bool isExclusive, unsigned int maxlevel&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>warpSegScan</b> (T val, unsigned int flag, volatile T *s_data, volatile unsigned int *s_flags, T &amp;oVal, unsigned int &amp;oFlag)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2b9ad8992708c3ff0bb5d6479603b045"></a><!-- doxytag: member="cudpp_cta::segmentedScanWarps" ref="g2b9ad8992708c3ff0bb5d6479603b045" args="(T val1, unsigned int flag1, T val2, unsigned int flag2, T *s_data, unsigned int *s_flags)" -->
template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>segmentedScanWarps</b> (T val1, unsigned int flag1, T val2, unsigned int flag2, T *s_data, unsigned int *s_flags)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__cta.html#g1e22f2750f80d47cab975543f6afed40">segmentedScanCTA</a> (T *s_data, unsigned int *s_flags, unsigned int *s_indices, T *d_blockSums=0, unsigned int *d_blockFlags=0, unsigned int *d_blockIndices=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">CTA-level segmented scan routine;.  <a href="#g1e22f2750f80d47cab975543f6afed40"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The CUDPP CTA-Level API contains functions that run on the GPU device. These are CUDA <code>__device__</code> functions that are called from within other CUDA device functions (typically <a class="el" href="group__cudpp__kernel.html">CUDPP Kernel-Level API</a> functions). They are called CTA-level functions because they typically process s_data "owned" by each CTA within shared memory, and are agnostic of any other CTAs that may be running (or how many CTAs are running), other than to compute appropriate global memory addresses. <hr><h2>Define Documentation</h2>
<a class="anchor" name="gb75dfd738e3beffebf497fbf120019fb"></a><!-- doxytag: member="scan_cta.cu::DISALLOW_LOADSTORE_OVERLAP" ref="gb75dfd738e3beffebf497fbf120019fb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISALLOW_LOADSTORE_OVERLAP&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is used to insert syncthreads to avoid perf loss caused by 128-bit load overlap that happens on G80. This gives about a 15% boost on scans on G80. <dl class="todo" compact><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Parameterize this in case this perf detail changes on future GPUs. </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g05ad3c672e73b35a200893881f3d1cd2"></a><!-- doxytag: member="radixsort_cta.cu::floatFlip" ref="g05ad3c672e73b35a200893881f3d1cd2" args="(uint f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool doFlip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ uint floatFlip           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flips bits of single-precision floating-point number (parameterized by doFlip). 
<p>
flip a float for sorting finds SIGN of fp number. if it's 1 (negative float), it flips all bits if it's 0 (positive float), it flips the sign only <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f</em>&nbsp;</td><td>floating-point input (passed as unsigned int) </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#g3cf28e5904a54e10af2d1c3fea729a59" title="Reverses bit-flip of single-precision floating-point number (parameterized by doFlip)...">floatUnflip</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3cf28e5904a54e10af2d1c3fea729a59"></a><!-- doxytag: member="radixsort_cta.cu::floatUnflip" ref="g3cf28e5904a54e10af2d1c3fea729a59" args="(uint f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool doFlip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ uint floatUnflip           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reverses bit-flip of single-precision floating-point number (parameterized by doFlip). 
<p>
flip a float back (invert FloatFlip) signed was flipped from above, so: if sign is 1 (negative), it flips the sign bit back if sign is 0 (positive), it flips all bits back <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f</em>&nbsp;</td><td>floating-point input (passed as unsigned int) </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#g05ad3c672e73b35a200893881f3d1cd2" title="Flips bits of single-precision floating-point number (parameterized by doFlip).">floatFlip</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd65926bbfd7939404fa697e7b23a2286"></a><!-- doxytag: member="radixsort_cta.cu::scanwarp" ref="gd65926bbfd7939404fa697e7b23a2286" args="(T val, T *sData)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int maxlevel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ T scanwarp           </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>sData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans one warp quickly, optimized for 32-element warps, using shared memory. 
<p>
Scans each warp in parallel ("warp-scan"), one element per thread. uses 2 numElements of shared memory per thread (64 numElements per warp)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Elements per thread to scan </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sData</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gbfa515588187af6524cbfd4d76fd16c5"></a><!-- doxytag: member="radixsort_cta.cu::scan4" ref="gbfa515588187af6524cbfd4d76fd16c5" args="(uint4 idata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ uint4 scan4           </td>
          <td>(</td>
          <td class="paramtype">uint4&nbsp;</td>
          <td class="paramname"> <em>idata</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scans 4*CTA_SIZE unsigned ints in a block. 
<p>
scan4 scans 4*CTA_SIZE numElements in a block (4 per thread), using a warp-scan algorithm<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idata</em>&nbsp;</td><td>4-vector of integers to scan </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gc598a1e6647cdfdb14ab24d0411ad1f5"></a><!-- doxytag: member="radixsort_cta.cu::rank4" ref="gc598a1e6647cdfdb14ab24d0411ad1f5" args="(uint4 preds)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int ctasize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ uint4 rank4           </td>
          <td>(</td>
          <td class="paramtype">uint4&nbsp;</td>
          <td class="paramname"> <em>preds</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes output position for each thread given predicate; trues come first then falses. 
<p>
Rank is the core of the radix sort loop. Given a predicate, it computes the output position for each thread in an ordering where all True threads come first, followed by all False threads. This version handles 4 predicates per thread; hence, "rank4".<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>preds</em>&nbsp;</td><td>true/false values for each of the 4 elements in this thread</td></tr>
  </table>
</dl>
<dl class="todo" compact><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>is the description of "preds" correct? </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd6197a166da7197ec317c4373a8ff232"></a><!-- doxytag: member="radixsort_cta.cu::radixSortBlock" ref="gd6197a166da7197ec317c4373a8ff232" args="(uint4 &amp;key, uint4 &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void radixSortBlock           </td>
          <td>(</td>
          <td class="paramtype">uint4 &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts one block. 
<p>
Uses rank to sort one bit at a time: Sorts a block according to bits startbit -&gt; nbits + startbit <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8927705927517481e2115784a2bf1876"></a><!-- doxytag: member="radixsort_cta.cu::radixSortBlockKeysOnly" ref="g8927705927517481e2115784a2bf1876" args="(uint4 &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void radixSortBlockKeysOnly           </td>
          <td>(</td>
          <td class="paramtype">uint4 &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts one block. Key-only version. 
<p>
Uses rank to sort one bit at a time: Sorts a block according to bits startbit -&gt; nbits + startbit <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g13c90ad7137a333b8ad2d3ccbb447fef"></a><!-- doxytag: member="rand_cta.cu::swizzleShift" ref="g13c90ad7137a333b8ad2d3ccbb447fef" args="(uint4 *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void swizzleShift           </td>
          <td>(</td>
          <td class="paramtype">uint4 *&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx. 
<p>
It does the equvalent of f-&gt;xyzw = f-&gt;yzwx since this functionality is in shading languages but not exposed in CUDA. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f</em>&nbsp;</td><td>the uint4 data type which will have its elements shifted. Passed in as pointer. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6139c8e2423bd271815ffb6feb572080"></a><!-- doxytag: member="rand_cta.cu::leftRotate" ref="g6139c8e2423bd271815ffb6feb572080" args="(unsigned int x, unsigned int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int leftRotate           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotates the bits in <em>x</em> over by <em>n</em> bits. 
<p>
This is the equivalent of the ROTATELEFT operation as described in the MD5 working memo. It takes the bits in <em>x</em> and circular shifts it over by <em>n</em> bits.<p>
For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>the variable with the bits </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>the number of bits to shift left by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gf6d7ad89002d2bc4ea5dfda74c5044c0"></a><!-- doxytag: member="rand_cta.cu::F" ref="gf6d7ad89002d2bc4ea5dfda74c5044c0" args="(unsigned int x, unsigned int y, unsigned int z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int F           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The F scrambling function. 
<p>
The F function in the MD5 technical memo scrambles three variables <em>x</em>, <em>y</em>, and <em>z</em> in the following way using bitwise logic:<p>
(x &amp; y) | ((~x) &amp; z)<p>
The resulting value is returned as an unsigned int.<p>
For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>See the above formula </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>See the above formula </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>See the above formula</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#g441b30dd5f34b0f92a826e2835a2924b" title="The FF scrambling function.">FF()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g903661679dd9f375fc6cfbcb285f39b1"></a><!-- doxytag: member="rand_cta.cu::G" ref="g903661679dd9f375fc6cfbcb285f39b1" args="(unsigned int x, unsigned int y, unsigned int z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int G           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The G scrambling function. 
<p>
The G function in the MD5 technical memo scrambles three variables <em>x</em>, <em>y</em>, and <em>z</em> in the following way using bitwise logic:<p>
(x &amp; z) | ((~z) &amp; y)<p>
The resulting value is returned as an unsigned int.<p>
For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>See the above formula </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>See the above formula </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>See the above formula</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#g45ddf2b6f6e2a98ce150f592ba32d3fa" title="The GG scrambling function.">GG()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g573bcce88a259368f3c2025371bdf656"></a><!-- doxytag: member="rand_cta.cu::H" ref="g573bcce88a259368f3c2025371bdf656" args="(unsigned int x, unsigned int y, unsigned int z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int H           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The H scrambling function. 
<p>
The H function in the MD5 technical memo scrambles three variables <em>x</em>, <em>y</em>, and <em>z</em> in the following way using bitwise logic:<p>
(x ^ y ^ z)<p>
The resulting value is returned as an unsigned int.<p>
For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>See the above formula </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>See the above formula </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>See the above formula</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#gfa4aefc8ed889545483f0686a5da016f" title="The HH scrambling function.">HH()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf2de48c1f68ee34f9943390241961fb2"></a><!-- doxytag: member="rand_cta.cu::I" ref="gf2de48c1f68ee34f9943390241961fb2" args="(unsigned int x, unsigned int y, unsigned int z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int I           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The I scrambling function. 
<p>
The I function in the MD5 technical memo scrambles three variables <em>x</em>, <em>y</em>, and <em>z</em> in the following way using bitwise logic:<p>
(y ^ (x | ~z))<p>
The resulting value is returned as an unsigned int.<p>
For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>See the above formula </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>See the above formula </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>See the above formula</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#g19d04cb1fa018499b6f5ef3a873bdd50" title="The II scrambling function.">II()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g441b30dd5f34b0f92a826e2835a2924b"></a><!-- doxytag: member="rand_cta.cu::FF" ref="g441b30dd5f34b0f92a826e2835a2924b" args="(uint4 *td, int i, uint4 *Fr, float p, unsigned int *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void FF           </td>
          <td>(</td>
          <td class="paramtype">uint4 *&nbsp;</td>
          <td class="paramname"> <em>td</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&nbsp;</td>
          <td class="paramname"> <em>Fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The FF scrambling function. 
<p>
The FF function in the MD5 technical memo is a wrapper for the F scrambling function as well as performing its own rotations using LeftRotate and swizzleShift. The variable <em>td</em> is the current scrambled digest which is passed along and scrambled using the current iteration <em>i</em>, the rotation information <em>Fr</em>, and the starting input <em>data</em>. <em>p</em> is kept as a constant of 2^32. The resulting value is stored in <em>td</em>.<p>
For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>td</em>&nbsp;</td><td>The current value of the digest stored as an uint4. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i</em>&nbsp;</td><td>The current iteration of the algorithm. This affects the values in <em>data</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Fr</em>&nbsp;</td><td>The current rotation order. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>The constant 2^32. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The starting input to MD5. Padded from <a class="el" href="group__cudpp__cta.html#gd815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a>.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#gf6d7ad89002d2bc4ea5dfda74c5044c0" title="The F scrambling function.">F()</a> <p>
<a class="el" href="group__cudpp__cta.html#g13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a> <p>
<a class="el" href="group__cudpp__cta.html#g6139c8e2423bd271815ffb6feb572080" title="Rotates the bits in x over by n bits.">leftRotate()</a> <p>
<a class="el" href="group__cudpp__cta.html#gd815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g45ddf2b6f6e2a98ce150f592ba32d3fa"></a><!-- doxytag: member="rand_cta.cu::GG" ref="g45ddf2b6f6e2a98ce150f592ba32d3fa" args="(uint4 *td, int i, uint4 *Gr, float p, unsigned int *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void GG           </td>
          <td>(</td>
          <td class="paramtype">uint4 *&nbsp;</td>
          <td class="paramname"> <em>td</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&nbsp;</td>
          <td class="paramname"> <em>Gr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The GG scrambling function. 
<p>
The GG function in the MD5 technical memo is a wrapper for the G scrambling function as well as performing its own rotations using LeftRotate() and <a class="el" href="group__cudpp__cta.html#g13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a>. The variable <em>td</em> is the current scrambled digest which is passed along and scrambled using the current iteration <em>i</em>, the rotation information <em>Gr</em>, and the starting input <em>data</em>. <em>p</em> is kept as a constant of 2^32. The resulting value is stored in <em>td</em>.<p>
For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>td</em>&nbsp;</td><td>The current value of the digest stored as an uint4. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i</em>&nbsp;</td><td>The current iteration of the algorithm. This affects the values in <em>data</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Gr</em>&nbsp;</td><td>The current rotation order. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>The constant 2^32. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The starting input to MD5. Padded from <a class="el" href="group__cudpp__cta.html#gd815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a>.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#g903661679dd9f375fc6cfbcb285f39b1" title="The G scrambling function.">G()</a> <p>
<a class="el" href="group__cudpp__cta.html#g13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a> <p>
<a class="el" href="group__cudpp__cta.html#g6139c8e2423bd271815ffb6feb572080" title="Rotates the bits in x over by n bits.">leftRotate()</a> <p>
<a class="el" href="group__cudpp__cta.html#gd815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfa4aefc8ed889545483f0686a5da016f"></a><!-- doxytag: member="rand_cta.cu::HH" ref="gfa4aefc8ed889545483f0686a5da016f" args="(uint4 *td, int i, uint4 *Hr, float p, unsigned int *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void HH           </td>
          <td>(</td>
          <td class="paramtype">uint4 *&nbsp;</td>
          <td class="paramname"> <em>td</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&nbsp;</td>
          <td class="paramname"> <em>Hr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The HH scrambling function. 
<p>
The HH function in the MD5 technical memo is a wrapper for the H scrambling function as well as performing its own rotations using LeftRotate() and <a class="el" href="group__cudpp__cta.html#g13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a>. The variable <em>td</em> is the current scrambled digest which is passed along and scrambled using the current iteration <em>i</em>, the rotation information <em>Hr</em>, and the starting input <em>data</em>. <em>p</em> is kept as a constant of 2^32. The resulting value is stored in <em>td</em>.<p>
For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>td</em>&nbsp;</td><td>The current value of the digest stored as an uint4. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i</em>&nbsp;</td><td>The current iteration of the algorithm. This affects the values in <em>data</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Hr</em>&nbsp;</td><td>The current rotation order. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>The constant 2^32. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The starting input to MD5. Padded from <a class="el" href="group__cudpp__cta.html#gd815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a>.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#g573bcce88a259368f3c2025371bdf656" title="The H scrambling function.">H()</a> <p>
<a class="el" href="group__cudpp__cta.html#g13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a> <p>
<a class="el" href="group__cudpp__cta.html#g6139c8e2423bd271815ffb6feb572080" title="Rotates the bits in x over by n bits.">leftRotate()</a> <p>
<a class="el" href="group__cudpp__cta.html#gd815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g19d04cb1fa018499b6f5ef3a873bdd50"></a><!-- doxytag: member="rand_cta.cu::II" ref="g19d04cb1fa018499b6f5ef3a873bdd50" args="(uint4 *td, int i, uint4 *Ir, float p, unsigned int *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void II           </td>
          <td>(</td>
          <td class="paramtype">uint4 *&nbsp;</td>
          <td class="paramname"> <em>td</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&nbsp;</td>
          <td class="paramname"> <em>Ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The II scrambling function. 
<p>
The II function in the MD5 technical memo is a wrapper for the I scrambling function as well as performing its own rotations using LeftRotate() and <a class="el" href="group__cudpp__cta.html#g13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a>. The variable <em>td</em> is the current scrambled digest which is passed along and scrambled using the current iteration <em>i</em>, the rotation information <em>Ir</em>, and the starting input <em>data</em>. <em>p</em> is kept as a constant of 2^32. The resulting value is stored in <em>td</em>.<p>
For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>td</em>&nbsp;</td><td>The current value of the digest stored as an uint4. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i</em>&nbsp;</td><td>The current iteration of the algorithm. This affects the values in <em>data</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Ir</em>&nbsp;</td><td>The current rotation order. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>The constant 2^32. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The starting input to MD5. Padded from <a class="el" href="group__cudpp__cta.html#gd815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a>.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#gf2de48c1f68ee34f9943390241961fb2" title="The I scrambling function.">I()</a> <p>
<a class="el" href="group__cudpp__cta.html#g13c90ad7137a333b8ad2d3ccbb447fef" title="Does a GLSL-style swizzle assigning f-&gt;xyzw = f-&gt;yzwx.">swizzleShift()</a> <p>
<a class="el" href="group__cudpp__cta.html#g6139c8e2423bd271815ffb6feb572080" title="Rotates the bits in x over by n bits.">leftRotate()</a> <p>
<a class="el" href="group__cudpp__cta.html#gd815ed3373fd7ed8be004190d392a429" title="Sets up the input array using information of seed, and threadIdx.">setupInput()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd815ed3373fd7ed8be004190d392a429"></a><!-- doxytag: member="rand_cta.cu::setupInput" ref="gd815ed3373fd7ed8be004190d392a429" args="(unsigned int *input, unsigned int seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void setupInput           </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>seed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up the <em>input</em> array using information of <em>seed</em>, and <em>threadIdx</em>. 
<p>
This function sets up the <em>input</em> array using a combination of the current thread's id and the user supplied <em>seed</em>.<p>
For more information see: <a href="http://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>input</em>&nbsp;</td><td>The array which will contain the initial values for all the scrambling functions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>seed</em>&nbsp;</td><td>The user supplied seed as an unsigned int.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__cudpp__cta.html#g441b30dd5f34b0f92a826e2835a2924b" title="The FF scrambling function.">FF()</a> <p>
<a class="el" href="group__cudpp__cta.html#g45ddf2b6f6e2a98ce150f592ba32d3fa" title="The GG scrambling function.">GG()</a> <p>
<a class="el" href="group__cudpp__cta.html#gfa4aefc8ed889545483f0686a5da016f" title="The HH scrambling function.">HH()</a> <p>
<a class="el" href="group__cudpp__cta.html#g19d04cb1fa018499b6f5ef3a873bdd50" title="The II scrambling function.">II()</a> <p>
<a class="el" href="group__cudpp__kernel.html#ga69e40f48791d63cdd66d101a22f6a4a" title="The main MD5 generation algorithm.">gen_randMD5()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc07542291db720d7382ab8c261c0f274"></a><!-- doxytag: member="scan_cta.cu::loadSharedChunkFromMem4" ref="gc07542291db720d7382ab8c261c0f274" args="(T *s_out, T threadScan0[4], T threadScan1[4], const T *d_in, int numElements, int iDataOffset, int &amp;ai, int &amp;bi, int &amp;aiDev, int &amp;biDev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void loadSharedChunkFromMem4           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>s_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>threadScan0</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>threadScan1</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iDataOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>aiDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>biDev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handles loading input s_data from global memory to shared memory (vec4 version). 
<p>
Load a chunk of 8*blockDim.x elements from global memory into a shared memory array. Each thread loads two T4 elements (where T4 is, e.g. int4 or float4), computes the scan of those two vec4s in thread local arrays (in registers), and writes the two total sums of the vec4s into shared memory, where they will be cooperatively scanned with the other partial sums by all threads in the CTA.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>s_out</em>&nbsp;</td><td>The output (shared) memory array </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>threadScan0</em>&nbsp;</td><td>Intermediate per-thread partial sums array 1 </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>threadScan1</em>&nbsp;</td><td>Intermediate per-thread partial sums array 2 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d_in</em>&nbsp;</td><td>The input (device) memory array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>The number of elements in the array being scanned </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iDataOffset</em>&nbsp;</td><td>the offset of the input array in global memory for this thread block </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ai</em>&nbsp;</td><td>The shared memory address for the thread's first element (returned for reuse) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bi</em>&nbsp;</td><td>The shared memory address for the thread's second element (returned for reuse) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>aiDev</em>&nbsp;</td><td>The device memory address for this thread's first element (returned for reuse) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>biDev</em>&nbsp;</td><td>The device memory address for this thread's second element (returned for reuse) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g57d07bd79aea5f056c2c0fbfc604872a"></a><!-- doxytag: member="scan_cta.cu::storeSharedChunkToMem4" ref="g57d07bd79aea5f056c2c0fbfc604872a" args="(T *d_out, T threadScan0[4], T threadScan1[4], T *s_in, int numElements, int oDataOffset, int ai, int bi, int aiDev, int biDev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void storeSharedChunkToMem4           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>threadScan0</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>threadScan1</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>s_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>oDataOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aiDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>biDev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handles storing result s_data from shared memory to global memory (vec4 version). 
<p>
Store a chunk of SCAN_ELTS_PER_THREAD*blockDim.x elements from shared memory into a device memory array. Each thread stores reads two elements from shared memory, adds them to the intermediate sums computed in <a class="el" href="group__cudpp__cta.html#gc07542291db720d7382ab8c261c0f274" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadSharedChunkFromMem4()</a>, and writes two T4 elements (where T4 is, e.g. int4 or float4) to global memory.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_out</em>&nbsp;</td><td>The output (device) memory array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadScan0</em>&nbsp;</td><td>Intermediate per-thread partial sums array 1 (contents computed in <a class="el" href="group__cudpp__cta.html#gc07542291db720d7382ab8c261c0f274" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadScan1</em>&nbsp;</td><td>Intermediate per-thread partial sums array 2 (contents computed in <a class="el" href="group__cudpp__cta.html#gc07542291db720d7382ab8c261c0f274" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>s_in</em>&nbsp;</td><td>The input (shared) memory array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>The number of elements in the array being scanned </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>oDataOffset</em>&nbsp;</td><td>the offset of the output array in global memory for this thread block </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ai</em>&nbsp;</td><td>The shared memory address for the thread's first element (computed in <a class="el" href="group__cudpp__cta.html#gc07542291db720d7382ab8c261c0f274" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bi</em>&nbsp;</td><td>The shared memory address for the thread's second element (computed in <a class="el" href="group__cudpp__cta.html#gc07542291db720d7382ab8c261c0f274" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aiDev</em>&nbsp;</td><td>The device memory address for this thread's first element (computed in <a class="el" href="group__cudpp__cta.html#gc07542291db720d7382ab8c261c0f274" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadSharedChunkFromMem4()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>biDev</em>&nbsp;</td><td>The device memory address for this thread's second element (computed in <a class="el" href="group__cudpp__cta.html#gc07542291db720d7382ab8c261c0f274" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadSharedChunkFromMem4()</a>) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g2e02e951efac2a6fba038cd102ef0415"></a><!-- doxytag: member="scan_cta.cu::warpscan" ref="g2e02e951efac2a6fba038cd102ef0415" args="(T val, volatile T *s_data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits , int maxlevel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ T warpscan           </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile T *&nbsp;</td>
          <td class="paramname"> <em>s_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scan all warps of a CTA without synchronization. 
<p>
The warp-scan algorithm breaks a block of data into warp-sized chunks, and scans the chunks independently with a warp of threads each. Because warps execute instructions in SIMD fashion, there is no need to synchronize in order to share data within a warp (only across warps). Also, in SIMD the most efficient algorithm is a step-efficient algorithm. Therefore, within each warp we use a Hillis-and-Steele-style scan that takes log2(N) steps to scan the warp [Daniel Hillis and Guy Steele 1986], rather than the work-efficient tree-based algorithm described by Guy Blelloch [1990] that takes 2 * log(N) steps and is in general more complex to implement. Previous versions of CUDPP used the Blelloch algorithm. For current GPUs, the warp size is 32, so this takes five steps per warp.<p>
Each thread is responsible for a single element of the array to be scanned. Each thread inputs a single value to the scan via <em>val</em> and returns its own scanned result element. The threads of each warp cooperate via the shared memory array <em>s_data</em> to scan WARP_SIZE elements.<p>
Template parameter <em>maxlevel</em> allows this warpscan to be performed on partial warps. For example, if only the first 8 elements of each warp need to be scanned, then warpscan only performs log2(8)=3 steps rather than 5.<p>
The computation uses 2 * WARP_SIZE elements of shared memory per warp to enable warps to offset beyond their input data and receive the identity element without using any branch instructions.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>s_data is declared volatile here to prevent the compiler from optimizing away writes to shared memory, and ensure correct intrawarp communication in the absence of __syncthreads.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The result of the warp scan for the current thread </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>The current threads's input to the scan </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>s_data</em>&nbsp;</td><td>A pointer to a temporary shared array of 2*CTA_SIZE elements used to compute the warp scans </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g163e1d81b5e290f00dcdf77060bc5c40"></a><!-- doxytag: member="scan_cta.cu::scanWarps" ref="g163e1d81b5e290f00dcdf77060bc5c40" args="(T x, T y, T *s_data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void scanWarps           </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>s_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform a full CTA scan using the warp-scan algorithm. 
<p>
As described in the comment for <a class="el" href="group__cudpp__cta.html#g2e02e951efac2a6fba038cd102ef0415" title="Scan all warps of a CTA without synchronization.">warpscan()</a>, the warp-scan algorithm breaks a block of data into warp-sized chunks, and scans the chunks independently with a warp of threads each. To complete the scan, each warp <em>j</em> then writes its last element to element <em>j</em> of a temporary shared array. Then a single warp exclusive-scans these "warp sums". Finally, each thread adds the result of the warp sum scan to the result of the scan from the first pass.<p>
Because we scan 2*CTA_SIZE elements per thread, we have to call warpscan twice.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The first input value for the current thread </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The second input value for the current thread </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s_data</em>&nbsp;</td><td>Temporary shared memory space of 2*CTA_SIZE elements for performing the scan </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gc39bd4553f352fb03361a56b17be04ee"></a><!-- doxytag: member="scan_cta.cu::scanCTA" ref="gc39bd4553f352fb03361a56b17be04ee" args="(T *s_data, T *d_blockSums, unsigned int blockSumIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void scanCTA           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>s_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>d_blockSums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>blockSumIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
CTA-level scan routine; scans s_data in shared memory in each thread block. 
<p>
This function is the main CTA-level scan function. It may be called by other CUDA __global__ or __device__ functions. This function scans 2 * CTA_SIZE elements. Each thread is responsible for one element in each half of the input array. <dl class="note" compact><dt><b>Note:</b></dt><dd>This code is intended to be run on a CTA of 128 threads. Other sizes are untested.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>s_data</em>&nbsp;</td><td>The array to be scanned in shared memory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_blockSums</em>&nbsp;</td><td>Array of per-block sums </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blockSumIndex</em>&nbsp;</td><td>Location in <em>d_blockSums</em> to which to write this block's sum </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gf417327731b668f89a1a8a32ae715e63"></a><!-- doxytag: member="segmented_scan_cta.cu::loadForSegmentedScanSharedChunkFromMem4" ref="gf417327731b668f89a1a8a32ae715e63" args="(T *s_odata, T threadScan0[4], T threadScan1[4], unsigned int &amp;threadFlag, unsigned int *s_oflags, unsigned int *s_oindices, const T *d_idata, const unsigned int *d_iflags, int numElements, int iDataOffset, int &amp;ai, int &amp;bi, int &amp;aiDev, int &amp;biDev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void loadForSegmentedScanSharedChunkFromMem4           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>s_odata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>threadScan0</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>threadScan1</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>threadFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>s_oflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>s_oindices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>d_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&nbsp;</td>
          <td class="paramname"> <em>d_iflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iDataOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>aiDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>biDev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handles loading input s_data from global memory to shared memory (vec4 version). 
<p>
Load a chunk of 8*blockDim.x elements from global memory into a shared memory array. Each thread loads two T4 elements (where T4 is, e.g. int4 or float4), computes the segmented scan of those two vec4s in thread local arrays (in registers), and writes the two total sums of the vec4s into shared memory, where they will be cooperatively scanned with the other partial sums by all threads in the CTA.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>s_odata</em>&nbsp;</td><td>The output (shared) memory array </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>threadScan0</em>&nbsp;</td><td>Intermediate per-thread partial sums array 1 </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>threadScan1</em>&nbsp;</td><td>Intermediate per-thread partial sums array 2 </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>threadFlag</em>&nbsp;</td><td>Intermediate array which holds 8 flags as follows Temporary register threadFlag0[4] - the flags for the first 4 elements read Temporary register threadFlag1[4] - the flags for the second 4 elements read Temporary register threadScanFlag0[4] - the inclusive OR-scan for the flags in threadFlag0[4] Temporary register threadScanFlag1[4] - the inclusive OR-scan for the flags in threadFlag1[4] We storing the 16 flags 32 bits of threadFlag Bits 0...3 contains threadFlag0[0]...threadFlag0[3] Bits 4...7 contains threadFlag1[0]...threadFlag1[3] Bits 8...11 contains threadScanFlag0[0]...threadScanFlag0[3] Bits 11...15 contains threadScanFlag1[0]...threadScanFlag1[3] </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>s_oflags</em>&nbsp;</td><td>Output (shared) memory array of segment head flags </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>s_oindices</em>&nbsp;</td><td>Output (shared) memory array of indices. If a flag for a position (1-based) is set then index for that position is the position, 0 otherwise. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d_idata</em>&nbsp;</td><td>The input (device) memory array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d_iflags</em>&nbsp;</td><td>The input (device) memory array of segment head flags </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>The number of elements in the array being scanned </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iDataOffset</em>&nbsp;</td><td>the offset of the input array in global memory for this thread block </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ai</em>&nbsp;</td><td>The shared memory address for the thread's first element (returned for reuse) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bi</em>&nbsp;</td><td>The shared memory address for the thread's second element (returned for reuse) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>aiDev</em>&nbsp;</td><td>The device memory address for this thread's first element (returned for reuse) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>biDev</em>&nbsp;</td><td>The device memory address for this thread's second element (returned for reuse) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb970a2f1d36591efe8376d8a1eaf2964"></a><!-- doxytag: member="segmented_scan_cta.cu::storeForSegmentedScanSharedChunkToMem4" ref="gb970a2f1d36591efe8376d8a1eaf2964" args="(T *d_odata, T threadScan0[4], T threadScan1[4], unsigned int threadFlag, T *s_idata, unsigned int numElements, int oDataOffset, int ai, int bi, int aiDev, int biDev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void storeForSegmentedScanSharedChunkToMem4           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>d_odata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>threadScan0</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>threadScan1</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>threadFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>s_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>oDataOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aiDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>biDev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handles storing result s_data from shared memory to global memory (vec4 version). 
<p>
Store a chunk of 8*blockDim.x elements from shared memory into a device memory array. Each thread stores reads two elements from shared memory, adds them while respecting segment bouldaries, to the intermediate sums computed in <a class="el" href="group__cudpp__cta.html#gf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadForSegmentedScanSharedChunkFromMem4()</a>, and writes two T4 elements (where T4 is, e.g. int4 or float4) to global memory.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_odata</em>&nbsp;</td><td>The output (device) memory array </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>threadScan0</em>&nbsp;</td><td>Intermediate per-thread partial sums array 1 (contents computed in <a class="el" href="group__cudpp__cta.html#gf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadScan1</em>&nbsp;</td><td>Intermediate per-thread partial sums array 2 (contents computed in <a class="el" href="group__cudpp__cta.html#gf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadFlag</em>&nbsp;</td><td>Various flags that <a class="el" href="group__cudpp__cta.html#gf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadForSegmentedScanSharedChunkFromMem4()</a> needs to pass </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>s_idata</em>&nbsp;</td><td>The input (shared) memory array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>The number of elements in the array being scanned </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>oDataOffset</em>&nbsp;</td><td>the offset of the output array in global memory for this thread block </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ai</em>&nbsp;</td><td>The shared memory address for the thread's first element (computed in <a class="el" href="group__cudpp__cta.html#gf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bi</em>&nbsp;</td><td>The shared memory address for the thread's second element (computed in <a class="el" href="group__cudpp__cta.html#gf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aiDev</em>&nbsp;</td><td>The device memory address for this thread's first element (computed in <a class="el" href="group__cudpp__cta.html#gf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>biDev</em>&nbsp;</td><td>The device memory address for this thread's second element (computed in <a class="el" href="group__cudpp__cta.html#gf417327731b668f89a1a8a32ae715e63" title="Handles loading input s_data from global memory to shared memory (vec4 version).">loadForSegmentedScanSharedChunkFromMem4()</a>) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g1e22f2750f80d47cab975543f6afed40"></a><!-- doxytag: member="segmented_scan_cta.cu::segmentedScanCTA" ref="g1e22f2750f80d47cab975543f6afed40" args="(T *s_data, unsigned int *s_flags, unsigned int *s_indices, T *d_blockSums=0, unsigned int *d_blockFlags=0, unsigned int *d_blockIndices=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__device__ void segmentedScanCTA           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>s_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>s_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>s_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>d_blockSums</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>d_blockFlags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>d_blockIndices</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
CTA-level segmented scan routine;. 
<p>
Performs segmented scan on <em>s_data</em> in shared memory in each thread block with head flags in <em>s_flags</em> (<em>s_tflags</em> is a read-write copy of the head flags which are modified).<p>
This function is the main CTA-level segmented scan function. It may be called by other CUDA __global__ or __device__ functions. <dl class="note" compact><dt><b>Note:</b></dt><dd>This code is intended to be run on a CTA of 128 threads. Other sizes are untested.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>s_data</em>&nbsp;</td><td>Array to be scanned in shared memory </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>s_flags</em>&nbsp;</td><td>Read-only version of flags in shared memory </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>s_indices</em>&nbsp;</td><td>Temporary read-write indices array </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_blockSums</em>&nbsp;</td><td>Array of per-block sums </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_blockFlags</em>&nbsp;</td><td>Array of per-block OR-reduction of flags </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>d_blockIndices</em>&nbsp;</td><td>Array of per-block min-reduction of indices </td></tr>
  </table>
</dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jul 3 16:52:27 2009 for CUDPP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
