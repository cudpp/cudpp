<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: CUDPP Application-Level API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUDPP&#160;<span id="projectnumber">1.1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">CUDPP Application-Level API</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="member-group"></a>
Compact Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga6330d24384786e65158a2fc35f05ae9b">calculatCompactLaunchParams</a> (const unsigned int numElements, unsigned int &amp;numThreads, unsigned int &amp;numBlocks, unsigned int &amp;numEltsPerBlock)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate launch parameters for <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>.  <a href="#ga6330d24384786e65158a2fc35f05ae9b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40">compactArray</a> (T *d_out, size_t *d_numValidElements, const T *d_in, const unsigned int *d_isValid, size_t numElements, const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact the non-zero elements of an array.  <a href="#ga00003db78fb8a269263a5e1205257f40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21">allocCompactStorage</a> (<a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by <a class="el" href="group__public_interface.html#ga275bcc2d5cb5b0277027140aae9c51bd" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.  <a href="#gae84f008f74af507fb9da9568ee22bd21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga5f6b8e696bb6ec4d87d55046041dfb9e">freeCompactStorage</a> (<a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate storage used by <a class="el" href="group__public_interface.html#ga275bcc2d5cb5b0277027140aae9c51bd" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.  <a href="#ga5f6b8e696bb6ec4d87d55046041dfb9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gafccd7f148a985a1ec19b30cf1d00fdbf">cudppCompactDispatch</a> (void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements, const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch compactArray for the specified datatype.  <a href="#gafccd7f148a985a1ec19b30cf1d00fdbf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
RadixSort Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="cudpp_app::uint" ref="ga91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit, bool flip, bool unflip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga77e7cdc13117bec8e3fac63ed506167d">radixSortStep</a> (uint *keys, uint *values, const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one step of the radix sort. Sorts by nbits key bits per step, starting at startbit.  <a href="#ga77e7cdc13117bec8e3fac63ed506167d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool flip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaebe1791eec0e357c303bb2d9ec4b36ec">radixSortSingleBlock</a> (uint *keys, uint *values, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-block optimization for sorts of fewer than 4 * CTA_SIZE elements.  <a href="#gaebe1791eec0e357c303bb2d9ec4b36ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gab1667f9693c8cab1d7315a6d00d540a4">radixSort</a> (uint *keys, uint *values, const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan, size_t numElements, bool flipBits, int keyBits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main radix sort function.  <a href="#gab1667f9693c8cab1d7315a6d00d540a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga52d64ec8e0a8f5271b2903dc9bdcc93e">radixSortFloatKeys</a> (float *keys, uint *values, const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan, size_t numElements, bool negativeKeys, int keyBits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to call main radix sort function. For float configuration.  <a href="#ga52d64ec8e0a8f5271b2903dc9bdcc93e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit, bool flip, bool unflip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga3a2cf76508f6e445da5a39d7fdb56dc7">radixSortStepKeysOnly</a> (uint *keys, const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one step of the radix sort. Sorts by nbits key bits per step, starting at startbit.  <a href="#ga3a2cf76508f6e445da5a39d7fdb56dc7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool flip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gadfedbe21b41fd7e5689a629b8c82515e">radixSortSingleBlockKeysOnly</a> (uint *keys, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization for sorts of fewer than 4 * CTA_SIZE elements (keys only).  <a href="#gadfedbe21b41fd7e5689a629b8c82515e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gafec238286b9af532ff7cf375ccf12449">radixSortKeysOnly</a> (uint *keys, const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan, bool flipBits, size_t numElements, int keyBits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main radix sort function. For keys only configuration.  <a href="#gafec238286b9af532ff7cf375ccf12449"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gae35885aaee60d8aae06e318705661c04">radixSortFloatKeysOnly</a> (float *keys, const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan, bool negativeKeys, size_t numElements, int keyBits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to call main radix sort function. For floats and keys only.  <a href="#gae35885aaee60d8aae06e318705661c04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa31e4e3aeb95d0ece7a6036afb1e577"></a><!-- doxytag: member="cudpp_app::initDeviceParameters" ref="gafa31e4e3aeb95d0ece7a6036afb1e577" args="(CUDPPRadixSortPlan *plan)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>initDeviceParameters</b> (<a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaa6043ddac717a99c471bb3dc0fc3c0de">allocRadixSortStorage</a> (<a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">From the programmer-specified sort configuration, creates internal memory for performing the sort.  <a href="#gaa6043ddac717a99c471bb3dc0fc3c0de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga5b103658becc8dbb8c5ca1026ff61598">freeRadixSortStorage</a> (<a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates intermediate memory from allocRadixSortStorage.  <a href="#ga5b103658becc8dbb8c5ca1026ff61598"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaf0bcb604392916df89c08bef52718dd3">cudppRadixSortDispatch</a> (void *keys, void *values, size_t numElements, int keyBits, const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a sort on an array with a specified configuration.  <a href="#gaf0bcb604392916df89c08bef52718dd3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Scan Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , bool isBackward, bool isExclusive, CUDPPOperator op&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaab8062495149d43064e1f03b4a8f15f9">scanArrayRecursive</a> (T *d_out, const T *d_in, T **d_blockSums, size_t numElements, size_t numRows, const size_t *rowPitches, int level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform recursive scan on arbitrary size arrays.  <a href="#gaab8062495149d43064e1f03b4a8f15f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6">allocScanStorage</a> (<a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by scan.  <a href="#ga344e15dee4b3b2351c40bd9cc732bed6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga399f5095b183ad026687fd227802ba5c">freeScanStorage</a> (<a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block sums arrays in a <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object.  <a href="#ga399f5095b183ad026687fd227802ba5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d">cudppScanDispatch</a> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.  <a href="#ga49485cb95e21695293a9c35f8355336d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Segmented Scan Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , CUDPPOperator op, bool isBackward, bool isExclusive, bool doShiftFlagsLeft&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga95b432f174dbe82aa53b4e211afb025f">segmentedScanArrayRecursive</a> (T *d_out, const T *d_idata, const unsigned int *d_iflags, T **d_blockSums, unsigned int **d_blockFlags, unsigned int **d_blockIndices, int numElements, int level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform recursive scan on arbitrary size arrays.  <a href="#ga95b432f174dbe82aa53b4e211afb025f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga3b0e55a25cddc0de09de8d55caf7ef8e">allocSegmentedScanStorage</a> (<a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html">CUDPPSegmentedScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate block sums, block flags and block indices arrays in a <a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html" title="Plan class for segmented scan algorithm.">CUDPPSegmentedScanPlan</a> class.  <a href="#ga3b0e55a25cddc0de09de8d55caf7ef8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gae6591814174ffd2ff63491aff45f21db">freeSegmentedScanStorage</a> (<a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html">CUDPPSegmentedScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block sums, block flags and block indices arrays in a <a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html" title="Plan class for segmented scan algorithm.">CUDPPSegmentedScanPlan</a> class.  <a href="#gae6591814174ffd2ff63491aff45f21db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga2657ecd704d4a52c5c2279ce04e079d4">cudppSegmentedScanDispatch</a> (void *d_out, const void *d_idata, const unsigned int *d_iflags, int numElements, const <a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html">CUDPPSegmentedScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.  <a href="#ga2657ecd704d4a52c5c2279ce04e079d4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Sparse Matrix-Vector Multiply Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gac44b56717ad49b51acf9ae44327bf7f7">sparseMatrixVectorMultiply</a> (T *d_y, const T *d_x, const <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html">CUDPPSparseMatrixVectorMultiplyPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform matrix-vector multiply for sparse matrices and vectors of arbitrary size.  <a href="#gac44b56717ad49b51acf9ae44327bf7f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga7fb60fe52408870c8244f4d8c0a480c4">allocSparseMatrixVectorMultiplyStorage</a> (<a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html">CUDPPSparseMatrixVectorMultiplyPlan</a> *plan, const void *A, const unsigned int *rowindx, const unsigned int *indx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate product, flags and rowFindx (index of the last element of each row) array .  <a href="#ga7fb60fe52408870c8244f4d8c0a480c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gabaffa81bcc214fbc8a969c5757ba0689">freeSparseMatrixVectorMultiplyStorage</a> (<a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html">CUDPPSparseMatrixVectorMultiplyPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate product, flags and rowFindx (index of the last element of each row) array .  <a href="#gabaffa81bcc214fbc8a969c5757ba0689"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gae053da6f54f81f6e8a05c36ef16c16ef">cudppSparseMatrixVectorMultiplyDispatch</a> (void *d_y, const void *d_x, const <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html">CUDPPSparseMatrixVectorMultiplyPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a sparse matrix-vector multiply with the specified configuration.  <a href="#gae053da6f54f81f6e8a05c36ef16c16ef"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The CUDPP Application-Level API contains functions that run on the host CPU and invoke GPU routines in the CUDPP <a class="el" href="group__cudpp__kernel.html">Kernel-Level API</a>. Application-Level API functions are used by CUDPP <a class="el" href="group__public_interface.html">Public Interface</a> functions to implement CUDPP's core functionality. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6330d24384786e65158a2fc35f05ae9b"></a><!-- doxytag: member="compact_app.cu::calculatCompactLaunchParams" ref="ga6330d24384786e65158a2fc35f05ae9b" args="(const unsigned int numElements, unsigned int &amp;numThreads, unsigned int &amp;numBlocks, unsigned int &amp;numEltsPerBlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculatCompactLaunchParams </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numEltsPerBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate launch parameters for <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>. </p>
<p>Calculates the block size and number of blocks from the total number of elements and the maximum threads per block. Called by <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>.</p>
<p>The calculation is pretty straightforward - the number of blocks is calculated by dividing the number of input elements by the product of the number of threads in each CTA and the number of elements each thread will process. numThreads and numEltsPerBlock are also simple to calculate. Please note that in cases where numElements is not an exact multiple of SCAN_ELTS_PER_THREAD * CTA_SIZE we would have threads which do nothing or have a thread which will process less than SCAN_ELTS_PER_THREAD elements.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numThreads</td><td>Number of threads in each block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numBlocks</td><td>Number of blocks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numEltsPerBlock</td><td>Number of elements processed per block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00003db78fb8a269263a5e1205257f40"></a><!-- doxytag: member="compact_app.cu::compactArray" ref="ga00003db78fb8a269263a5e1205257f40" args="(T *d_out, size_t *d_numValidElements, const T *d_in, const unsigned int *d_isValid, size_t numElements, const CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compactArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compact the non-zero elements of an array. </p>
<p>Given an input array <em>d_in</em>, <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a> outputs a compacted version which does not have null (zero) elements. Also ouputs the number of non-zero elements in the compacted array. Called by <a class="el" href="group__cudpp__app.html#gafccd7f148a985a1ec19b30cf1d00fdbf" title="Dispatch compactArray for the specified datatype.">cudppCompactDispatch()</a>.</p>
<p>The algorithm is straightforward, involving two steps (most of the complexity is hidden in scan, invoked with <a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d" title="Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.">cudppScanDispatch()</a> ).</p>
<ol type="1">
<li>scanArray() performs a prefix sum on <em>d_isValid</em> to compute output indices.</li>
<li><a class="el" href="group__cudpp__kernel.html#ga02aca9cfcac6799d445c857626e7d317" title="Consolidate non-null elements - for each non-null element in d_in write it to d_out, in the position specified by d_isValid. Called by compactArray().">compactData()</a> takes <em>d_in</em> and an intermediate array of output indices as input and writes the values with valid flags in <em>d_isValid</em> into <em>d_out</em> using the output indices.</li>
</ol>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Array of compacted non-null elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>Pointer to unsigned int to store number of non-null elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_isValid</td><td>Array of flags, 1 for each non-null element, 0 for each null element. Same length as <em>d_in</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this compact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae84f008f74af507fb9da9568ee22bd21"></a><!-- doxytag: member="compact_app.cu::allocCompactStorage" ref="gae84f008f74af507fb9da9568ee22bd21" args="(CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocCompactStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by <a class="el" href="group__public_interface.html#ga275bcc2d5cb5b0277027140aae9c51bd" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>. </p>
<p>In addition to the internal <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> contained in <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a>, CUDPPCompact also needs a temporary device array of output indices, which is allocated by this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a> object within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f6b8e696bb6ec4d87d55046041dfb9e"></a><!-- doxytag: member="compact_app.cu::freeCompactStorage" ref="ga5f6b8e696bb6ec4d87d55046041dfb9e" args="(CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeCompactStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate storage used by <a class="el" href="group__public_interface.html#ga275bcc2d5cb5b0277027140aae9c51bd" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>. </p>
<p>Deallocates the output indices array allocated by <a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21" title="Allocate intermediate arrays used by cudppCompact().">allocCompactStorage()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21" title="Allocate intermediate arrays used by cudppCompact().">allocCompactStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafccd7f148a985a1ec19b30cf1d00fdbf"></a><!-- doxytag: member="compact_app.cu::cudppCompactDispatch" ref="gafccd7f148a985a1ec19b30cf1d00fdbf" args="(void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements, const CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppCompactDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch compactArray for the specified datatype. </p>
<p>A thin wrapper on top of compactArray which calls <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a> for the data type specified in <em>config</em>. This is the app-level interface to compact used by <a class="el" href="group__public_interface.html#ga275bcc2d5cb5b0277027140aae9c51bd" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Compacted array of non-zero elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>Pointer to an unsigned int to store the number of non-zero elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isValid</td><td>Array of boolean valid flags with same length as <em>d_in</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compact </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to plan object for this compact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga77e7cdc13117bec8e3fac63ed506167d"></a><!-- doxytag: member="radixsort_app.cu::radixSortStep" ref="ga77e7cdc13117bec8e3fac63ed506167d" args="(uint *keys, uint *values, const CUDPPRadixSortPlan *plan, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit, bool flip, bool unflip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void radixSortStep </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform one step of the radix sort. Sorts by nbits key bits per step, starting at startbit. </p>
<p>Uses <a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d" title="Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.">cudppScanDispatch()</a> for the prefix sum of radix counters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebe1791eec0e357c303bb2d9ec4b36ec"></a><!-- doxytag: member="radixsort_app.cu::radixSortSingleBlock" ref="gaebe1791eec0e357c303bb2d9ec4b36ec" args="(uint *keys, uint *values, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool flip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void radixSortSingleBlock </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Single-block optimization for sorts of fewer than 4 * CTA_SIZE elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab1667f9693c8cab1d7315a6d00d540a4"></a><!-- doxytag: member="radixsort_app.cu::radixSort" ref="gab1667f9693c8cab1d7315a6d00d540a4" args="(uint *keys, uint *values, const CUDPPRadixSortPlan *plan, size_t numElements, bool flipBits, int keyBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void radixSort </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main radix sort function. </p>
<p>Main radix sort function. Sorts in place in the keys and values arrays, but uses the other device arrays as temporary storage. All pointer parameters are device pointers. Uses <a class="el" href="group__public_interface.html#ga6d637cd697e495985afbb1c3e64a21f7" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in G...">cudppScan()</a> for the prefix sum of radix counters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flipBits</td><td>Is set true if key datatype is a float (neg. numbers) for special float sorting operations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBits</td><td>Number of interesting bits in the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga52d64ec8e0a8f5271b2903dc9bdcc93e"></a><!-- doxytag: member="radixsort_app.cu::radixSortFloatKeys" ref="ga52d64ec8e0a8f5271b2903dc9bdcc93e" args="(float *keys, uint *values, const CUDPPRadixSortPlan *plan, size_t numElements, bool negativeKeys, int keyBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void radixSortFloatKeys </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>negativeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper to call main radix sort function. For float configuration. </p>
<p>Calls the main radix sort function. For float configuration.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">negativeKeys</td><td>Is set true if key datatype has neg. numbers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBits</td><td>Number of interesting bits in the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a2cf76508f6e445da5a39d7fdb56dc7"></a><!-- doxytag: member="radixsort_app.cu::radixSortStepKeysOnly" ref="ga3a2cf76508f6e445da5a39d7fdb56dc7" args="(uint *keys, const CUDPPRadixSortPlan *plan, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit, bool flip, bool unflip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void radixSortStepKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform one step of the radix sort. Sorts by nbits key bits per step, starting at startbit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadfedbe21b41fd7e5689a629b8c82515e"></a><!-- doxytag: member="radixsort_app.cu::radixSortSingleBlockKeysOnly" ref="gadfedbe21b41fd7e5689a629b8c82515e" args="(uint *keys, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool flip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void radixSortSingleBlockKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimization for sorts of fewer than 4 * CTA_SIZE elements (keys only). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafec238286b9af532ff7cf375ccf12449"></a><!-- doxytag: member="radixsort_app.cu::radixSortKeysOnly" ref="gafec238286b9af532ff7cf375ccf12449" args="(uint *keys, const CUDPPRadixSortPlan *plan, bool flipBits, size_t numElements, int keyBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void radixSortKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main radix sort function. For keys only configuration. </p>
<p>Main radix sort function. Sorts in place in the keys array, but uses the other device arrays as temporary storage. All pointer parameters are device pointers. Uses scan for the prefix sum of radix counters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flipBits</td><td>Is set true if key datatype is a float (neg. numbers) for special float sorting operations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBits</td><td>Number of interesting bits in the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae35885aaee60d8aae06e318705661c04"></a><!-- doxytag: member="radixsort_app.cu::radixSortFloatKeysOnly" ref="gae35885aaee60d8aae06e318705661c04" args="(float *keys, const CUDPPRadixSortPlan *plan, bool negativeKeys, size_t numElements, int keyBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void radixSortFloatKeysOnly </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>negativeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper to call main radix sort function. For floats and keys only. </p>
<p>Calls the radixSortKeysOnly function setting parameters for floats.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">negativeKeys</td><td>Is set true if key flipBits is to be true in <a class="el" href="group__cudpp__app.html#gafec238286b9af532ff7cf375ccf12449" title="Main radix sort function. For keys only configuration.">radixSortKeysOnly()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBits</td><td>Number of interesting bits in the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa6043ddac717a99c471bb3dc0fc3c0de"></a><!-- doxytag: member="radixsort_app.cu::allocRadixSortStorage" ref="gaa6043ddac717a99c471bb3dc0fc3c0de" args="(CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocRadixSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From the programmer-specified sort configuration, creates internal memory for performing the sort. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html" title="Plan class for sort algorithm.">CUDPPRadixSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b103658becc8dbb8c5ca1026ff61598"></a><!-- doxytag: member="radixsort_app.cu::freeRadixSortStorage" ref="ga5b103658becc8dbb8c5ca1026ff61598" args="(CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeRadixSortStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocates intermediate memory from allocRadixSortStorage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html" title="Plan class for sort algorithm.">CUDPPRadixSortPlan</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0bcb604392916df89c08bef52718dd3"></a><!-- doxytag: member="radixsort_app.cu::cudppRadixSortDispatch" ref="gaf0bcb604392916df89c08bef52718dd3" args="(void *keys, void *values, size_t numElements, int keyBits, const CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppRadixSortDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_radix_sort_plan.html">CUDPPRadixSortPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a sort on an array with a specified configuration. </p>
<p>This is the dispatch routine which calls radixSort...() with appropriate template parameters and arguments as specified by the plan. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBits</td><td>Number of interesting bits in the key* </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab8062495149d43064e1f03b4a8f15f9"></a><!-- doxytag: member="scan_app.cu::scanArrayRecursive" ref="gaab8062495149d43064e1f03b4a8f15f9" args="(T *d_out, const T *d_in, T **d_blockSums, size_t numElements, size_t numRows, const size_t *rowPitches, int level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool isBackward, bool isExclusive, CUDPPOperator op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scanArrayRecursive </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>d_blockSums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>rowPitches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform recursive scan on arbitrary size arrays. </p>
<p>This is the CPU-side workhorse function of the scan engine. This function invokes the CUDA kernels which perform the scan on individual blocks.</p>
<p>Scans of large arrays must be split (possibly recursively) into a hierarchy of block scans, where each block is scanned by a single CUDA thread block. At each recursive level of the scanArrayRecursive first invokes a kernel to scan all blocks of that level, and if the level has more than one block, it calls itself recursively. On returning from each recursive level, the total sum of each block from the level below is added to all elements of the corresponding block in this level. See "Parallel Prefix Sum (Scan) in CUDA" for more information (see <a class="el" href="index.html#references">References</a> ).</p>
<p>Template parameter <em>T</em> is the datatype; <em>isBackward</em> specifies backward or forward scan; <em>isExclusive</em> specifies exclusive or inclusive scan, and <em>op</em> specifies the binary associative operator to be used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array for the scan results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>Array of arrays of per-block sums (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows in the array to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowPitches</td><td>Array of row pitches (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The current recursive level of the scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga344e15dee4b3b2351c40bd9cc732bed6"></a><!-- doxytag: member="scan_app.cu::allocScanStorage" ref="ga344e15dee4b3b2351c40bd9cc732bed6" args="(CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by scan. </p>
<p>Scans of large arrays must be split (possibly recursively) into a hierarchy of block scans, where each block is scanned by a single CUDA thread block. At each recursive level of the scan, we need an array in which to store the total sums of all blocks in that level. This function computes the amount of storage needed and allocates it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga399f5095b183ad026687fd227802ba5c"></a><!-- doxytag: member="scan_app.cu::freeScanStorage" ref="ga399f5095b183ad026687fd227802ba5c" args="(CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate block sums arrays in a <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object. </p>
<p>These arrays must have been allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>, which is called by the constructor of cudppScanPlan().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga49485cb95e21695293a9c35f8355336d"></a><!-- doxytag: member="scan_app.cu::cudppScanDispatch" ref="ga49485cb95e21695293a9c35f8355336d" args="(void *d_out, const void *d_in, size_t numElements, size_t numRows, const CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppScanDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a scan (prefix sum) on an array with the specified configuration. </p>
<p>This is the dispatch routine which calls <a class="el" href="group__cudpp__app.html#gaab8062495149d43064e1f03b4a8f15f9" title="Perform recursive scan on arbitrary size arrays.">scanArrayRecursive()</a> with appropriate template parameters and arguments to achieve the scan as specified in <em>plan</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array of scan results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows to scan in parallel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object containing scan options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga95b432f174dbe82aa53b4e211afb025f"></a><!-- doxytag: member="segmented_scan_app.cu::segmentedScanArrayRecursive" ref="ga95b432f174dbe82aa53b4e211afb025f" args="(T *d_out, const T *d_idata, const unsigned int *d_iflags, T **d_blockSums, unsigned int **d_blockFlags, unsigned int **d_blockIndices, int numElements, int level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , CUDPPOperator op, bool isBackward, bool isExclusive, bool doShiftFlagsLeft&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void segmentedScanArrayRecursive </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_iflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>d_blockSums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int **&#160;</td>
          <td class="paramname"><em>d_blockFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int **&#160;</td>
          <td class="paramname"><em>d_blockIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform recursive scan on arbitrary size arrays. </p>
<p>This is the CPU-side workhorse function of the segmented scan engine. This function invokes the CUDA kernels which perform the segmented scan on individual blocks.</p>
<p>Scans of large arrays must be split (possibly recursively) into a hierarchy of block scans, where each block is scanned by a single CUDA thread block. At each recursive level of the segmentedScanArrayRecursive first invokes a kernel to scan all blocks of that level, and if the level has more than one block, it calls itself recursively. On returning from each recursive level, the total sum of each block from the level below is added to all elements of the first segment of the corresponding block in this level.</p>
<p>Template parameter T is the data type of the input data. Template parameter op is the binary operator of the segmented scan. Template parameter isBackward specifies whether the direction is backward (not implemented). It is forward if it is false. Template parameter isExclusive specifies whether the segmented scan is exclusive (true) or inclusive (false).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array for the segmented scan results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_idata</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_iflags</td><td>The input flags vector which specifies the segments. The first element of a segment is marked by a 1 in the corresponding position in d_iflags vector. All other elements of d_iflags is 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>Array of arrays of per-block sums (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockFlags</td><td>Array of arrays of per-block OR-reductions of flags (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockIndices</td><td>Array of arrays of per-block min-reductions of indices (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga3b0e55a25cddc0de09de8d55caf7ef8e" title="Allocate intermediate block sums, block flags and block indices arrays in a CUDPPSegmentedScanPlan cl...">allocSegmentedScanStorage()</a>). An index for a particular position <code>i</code> in a block is calculated as - if <code>d_iflags</code>[i] is set then it is the 1-based index of that position (i.e if <code>d_iflags</code>[10] is set then index is <code>11</code>) otherwise the index is <code>INT_MAX</code> (the identity element of a min operator) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The current recursive level of the scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b0e55a25cddc0de09de8d55caf7ef8e"></a><!-- doxytag: member="segmented_scan_app.cu::allocSegmentedScanStorage" ref="ga3b0e55a25cddc0de09de8d55caf7ef8e" args="(CUDPPSegmentedScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocSegmentedScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html">CUDPPSegmentedScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate block sums, block flags and block indices arrays in a <a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html" title="Plan class for segmented scan algorithm.">CUDPPSegmentedScanPlan</a> class. </p>
<p>Segmented scans of large arrays must be split (possibly recursively) into a hierarchy of block segmented scans, where each block is scanned by a single CUDA thread block. At each recursive level of the scan, we need an array in which to store the total sums of all blocks in that level. Also at this level we have two more arrays - one which contains the OR-reductions of flags of all blocks at that level and the second which contains the min-reductions of indices of all blocks at that levels This function computes the amount of storage needed and allocates it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html" title="Plan class for segmented scan algorithm.">CUDPPSegmentedScanPlan</a> object containing segmented scan options and number of elements, which is used to compute storage requirements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae6591814174ffd2ff63491aff45f21db"></a><!-- doxytag: member="segmented_scan_app.cu::freeSegmentedScanStorage" ref="gae6591814174ffd2ff63491aff45f21db" args="(CUDPPSegmentedScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeSegmentedScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html">CUDPPSegmentedScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate block sums, block flags and block indices arrays in a <a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html" title="Plan class for segmented scan algorithm.">CUDPPSegmentedScanPlan</a> class. </p>
<p>These arrays must have been allocated by <a class="el" href="group__cudpp__app.html#ga3b0e55a25cddc0de09de8d55caf7ef8e" title="Allocate intermediate block sums, block flags and block indices arrays in a CUDPPSegmentedScanPlan cl...">allocSegmentedScanStorage()</a>, which is called by the constructor of <a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html" title="Plan class for segmented scan algorithm.">CUDPPSegmentedScanPlan</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td><a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html" title="Plan class for segmented scan algorithm.">CUDPPSegmentedScanPlan</a> class initialized by its constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2657ecd704d4a52c5c2279ce04e079d4"></a><!-- doxytag: member="segmented_scan_app.cu::cudppSegmentedScanDispatch" ref="ga2657ecd704d4a52c5c2279ce04e079d4" args="(void *d_out, const void *d_idata, const unsigned int *d_iflags, int numElements, const CUDPPSegmentedScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppSegmentedScanDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_iflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html">CUDPPSegmentedScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a scan (prefix sum) on an array with the specified configuration. </p>
<p>This is the dispatch routine which calls <a class="el" href="group__cudpp__app.html#ga95b432f174dbe82aa53b4e211afb025f" title="Perform recursive scan on arbitrary size arrays.">segmentedScanArrayRecursive()</a> with appropriate template parameters and arguments to achieve the scan as specified in <em>plan</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Segmented Scan configuration (plan), initialized by <a class="el" href="class_c_u_d_p_p_segmented_scan_plan.html" title="Plan class for segmented scan algorithm.">CUDPPSegmentedScanPlan</a> constructor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_idata</td><td>The input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_iflags</td><td>The input flags array</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array of segmented scan results </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac44b56717ad49b51acf9ae44327bf7f7"></a><!-- doxytag: member="spmvmult_app.cu::sparseMatrixVectorMultiply" ref="gac44b56717ad49b51acf9ae44327bf7f7" args="(T *d_y, const T *d_x, const CUDPPSparseMatrixVectorMultiplyPlan *plan)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sparseMatrixVectorMultiply </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html">CUDPPSparseMatrixVectorMultiplyPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform matrix-vector multiply for sparse matrices and vectors of arbitrary size. </p>
<p>This function performs the sparse matrix-vector multiply by executing four steps.</p>
<p>1. The <a class="el" href="group__cudpp__kernel.html#gadc255d86178e5e591c3f2d2e8d5f564b" title="Fetch and multiply kernel.">sparseMatrixVectorFetchAndMultiply()</a> kernel does an element-wise multiplication of a each element e in <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#ab1a9f132ac3f74ac7f8d8d234df7a1ff">CUDPPSparseMatrixVectorMultiplyPlan::m_d_A</a> with the corresponding (i.e. in the same row as the column index of e in <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#ab1a9f132ac3f74ac7f8d8d234df7a1ff">CUDPPSparseMatrixVectorMultiplyPlan::m_d_A</a>) element in d_x and stores the product in <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#a3b0331160fdfe4fb1244280fa4ebf830">CUDPPSparseMatrixVectorMultiplyPlan::m_d_prod</a>. It also sets all elements of <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#a34c53c26450bbee6fc220249c5805a4c">CUDPPSparseMatrixVectorMultiplyPlan::m_d_flags</a> to 0.</p>
<p>2. The <a class="el" href="group__cudpp__kernel.html#ga650782aef0e14c36782f5c24cd96a8dd" title="Set Flags kernel.">sparseMatrixVectorSetFlags()</a> kernel iterates over each element in <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#ae480d029a82578a9cc72c6f32b8a3824">CUDPPSparseMatrixVectorMultiplyPlan::m_d_rowIndex</a> and sets the corresponding position (indicated by <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#ae480d029a82578a9cc72c6f32b8a3824">CUDPPSparseMatrixVectorMultiplyPlan::m_d_rowIndex</a>) in <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#a34c53c26450bbee6fc220249c5805a4c">CUDPPSparseMatrixVectorMultiplyPlan::m_d_flags</a> to 1.</p>
<p>3. Perform a segmented scan on <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#a3b0331160fdfe4fb1244280fa4ebf830">CUDPPSparseMatrixVectorMultiplyPlan::m_d_prod</a> with <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#a34c53c26450bbee6fc220249c5805a4c">CUDPPSparseMatrixVectorMultiplyPlan::m_d_flags</a> as the flag vector. The output is stored in <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#a3b0331160fdfe4fb1244280fa4ebf830">CUDPPSparseMatrixVectorMultiplyPlan::m_d_prod</a>.</p>
<p>4. The <a class="el" href="group__cudpp__kernel.html#ga01e289bd29d24bfc8e96dd853668900d" title="Gather final y values kernel.">yGather()</a> kernel goes over each element in <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#a3dc274beaef90b5b69e2e9d702713895">CUDPPSparseMatrixVectorMultiplyPlan::m_d_rowFinalIndex</a> and picks the corresponding element (indicated by <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#a3dc274beaef90b5b69e2e9d702713895">CUDPPSparseMatrixVectorMultiplyPlan::m_d_rowFinalIndex</a>) element from <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html#a3b0331160fdfe4fb1244280fa4ebf830">CUDPPSparseMatrixVectorMultiplyPlan::m_d_prod</a> and stores it in d_y.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_y</td><td>The output array for the sparse matrix-vector multiply (y vector) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_x</td><td>The input x vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html" title="Plan class for sparse-matrix dense-vector multiply.">CUDPPSparseMatrixVectorMultiplyPlan</a> object which stores the configuration and pointers to temporary buffers needed by this routine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7fb60fe52408870c8244f4d8c0a480c4"></a><!-- doxytag: member="spmvmult_app.cu::allocSparseMatrixVectorMultiplyStorage" ref="ga7fb60fe52408870c8244f4d8c0a480c4" args="(CUDPPSparseMatrixVectorMultiplyPlan *plan, const void *A, const unsigned int *rowindx, const unsigned int *indx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocSparseMatrixVectorMultiplyStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html">CUDPPSparseMatrixVectorMultiplyPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>rowindx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate product, flags and rowFindx (index of the last element of each row) array . </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html" title="Plan class for sparse-matrix dense-vector multiply.">CUDPPSparseMatrixVectorMultiplyPlan</a> class containing sparse matrix-vector multiply options, number of non-zero elements and number of rows which is used to compute storage requirements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowindx</td><td>The indices of elements in A which are the first element of their row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indx</td><td>The column number for each element in A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabaffa81bcc214fbc8a969c5757ba0689"></a><!-- doxytag: member="spmvmult_app.cu::freeSparseMatrixVectorMultiplyStorage" ref="gabaffa81bcc214fbc8a969c5757ba0689" args="(CUDPPSparseMatrixVectorMultiplyPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeSparseMatrixVectorMultiplyStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html">CUDPPSparseMatrixVectorMultiplyPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate product, flags and rowFindx (index of the last element of each row) array . </p>
<p>These arrays must have been allocated by <a class="el" href="group__cudpp__app.html#ga7fb60fe52408870c8244f4d8c0a480c4" title="Allocate intermediate product, flags and rowFindx (index of the last element of each row) array ...">allocSparseMatrixVectorMultiplyStorage()</a>, which is called by the constructor of <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html" title="Plan class for sparse-matrix dense-vector multiply.">CUDPPSparseMatrixVectorMultiplyPlan</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html" title="Plan class for sparse-matrix dense-vector multiply.">CUDPPSparseMatrixVectorMultiplyPlan</a> plan initialized by its constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae053da6f54f81f6e8a05c36ef16c16ef"></a><!-- doxytag: member="spmvmult_app.cu::cudppSparseMatrixVectorMultiplyDispatch" ref="gae053da6f54f81f6e8a05c36ef16c16ef" args="(void *d_y, const void *d_x, const CUDPPSparseMatrixVectorMultiplyPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppSparseMatrixVectorMultiplyDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_sparse_matrix_vector_multiply_plan.html">CUDPPSparseMatrixVectorMultiplyPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a sparse matrix-vector multiply with the specified configuration. </p>
<p>This is the dispatch routine which calls <a class="el" href="group__cudpp__app.html#gac44b56717ad49b51acf9ae44327bf7f7" title="Perform matrix-vector multiply for sparse matrices and vectors of arbitrary size.">sparseMatrixVectorMultiply()</a> with appropriate template parameters and arguments</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_y</td><td>The output vector for y = A*x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_x</td><td>The x vector for y = A*x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>The sparse matrix plan and data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Mar 8 2013 for CUDPP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
