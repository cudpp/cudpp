<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: CUDPP Kernel-Level API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUDPP&#160;<span id="projectnumber">2.0</span></div>
   <div id="projectbrief">CUDA Data-Parallel Primitives Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">CUDPP Kernel-Level API</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="member-group"></a>
Compact Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , bool isBackward&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga02aca9cfcac6799d445c857626e7d317">compactData</a> (T *d_out, size_t *d_numValidElements, const unsigned int *d_indices, const unsigned int *d_isValid, const T *d_in, unsigned int numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Consolidate non-null elements - for each non-null element in <em>d_in</em> write it to <em>d_out</em>, in the position specified by <em>d_isValid</em>. Called by <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>.  <a href="#ga02aca9cfcac6799d445c857626e7d317"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
RadixSort Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="cudpp_kernel::uint" ref="ga91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9b2c50ca94fbb436128f97475148d84"></a><!-- doxytag: member="cudpp_kernel::emptyKernel" ref="gad9b2c50ca94fbb436128f97475148d84" args="()" -->
__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gad9b2c50ca94fbb436128f97475148d84">emptyKernel</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">And empty kernel used to reset CTA issue hardware. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaa002e725192c3ac452f6c3168de2895a">flipFloats</a> (uint *values, uint numValues)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does special binary arithmetic before sorting floats.  <a href="#gaa002e725192c3ac452f6c3168de2895a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga359f23566212946fc94d7a61c9e4dfd3">unflipFloats</a> (uint *values, uint numValues)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Undoes the flips from flipFloats.  <a href="#ga359f23566212946fc94d7a61c9e4dfd3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool flip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga1c7394659289d6123e477c7b5b3a9e8b">radixSortSingleWarp</a> (uint *keys, uint *values, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization for sorts of WARP_SIZE or fewer elements.  <a href="#ga1c7394659289d6123e477c7b5b3a9e8b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool flip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gab4b5a78a353c90d1698b9b7321fa8c9d">radixSortSingleWarpKeysOnly</a> (uint *keys, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization for sorts of WARP_SIZE or fewer elements. Keys-Only version.  <a href="#gab4b5a78a353c90d1698b9b7321fa8c9d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga2cf5bfc2844ebb31e5859f7ef28cb975">radixSortBlocks</a> (uint4 *keysOut, uint4 *valuesOut, uint4 *keysIn, uint4 *valuesIn, uint numElements, uint totalBlocks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements  <a href="#ga2cf5bfc2844ebb31e5859f7ef28cb975"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint startbit, bool fullBlocks, bool loop&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga98fa842d18a6f9d366c1853ee8458426">findRadixOffsets</a> (uint2 *keys, uint *counters, uint *blockOffsets, uint numElements, uint totalBlocks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of keys of each radix in each block stores offset.  <a href="#ga98fa842d18a6f9d366c1853ee8458426"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga326b66a44772c53ef1657289c511252d">reorderData</a> (uint *outKeys, uint *outValues, uint2 *keys, uint2 *values, uint *blockOffsets, uint *offsets, uint *sizes, uint numElements, uint totalBlocks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders data in the global array.  <a href="#ga326b66a44772c53ef1657289c511252d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga5266ebf2bb30d8419cea059b1435d475">radixSortBlocksKeysOnly</a> (uint4 *keysOut, uint4 *keysIn, uint numElements, uint totalBlocks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements.  <a href="#ga5266ebf2bb30d8419cea059b1435d475"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gac8b6736ae3fa13bb852245f054cbd4eb">reorderDataKeysOnly</a> (uint *outKeys, uint2 *keys, uint *blockOffsets, uint *offsets, uint *sizes, uint numElements, uint totalBlocks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders data in the global array.  <a href="#gac8b6736ae3fa13bb852245f054cbd4eb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Rand Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaa69e40f48791d63cdd66d101a22f6a4a">gen_randMD5</a> (uint4 *d_out, size_t numElements, unsigned int seed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The main MD5 generation algorithm.  <a href="#gaa69e40f48791d63cdd66d101a22f6a4a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Reduce Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , class Oper , unsigned int blockSize, bool nIsPow2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gab64eb250a1594485b1b05a3c1458797d">reduce</a> (T *odata, const T *idata, unsigned int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main reduction kernel.  <a href="#gab64eb250a1594485b1b05a3c1458797d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Scan Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga68b0aa93e22b1b3fc622ed8d86bc4310">scan4</a> (T *d_out, const T *d_in, T *d_blockSums, int numElements, unsigned int dataRowPitch, unsigned int blockSumRowPitch)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main scan kernel.  <a href="#ga68b0aa93e22b1b3fc622ed8d86bc4310"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Segmented scan Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaf2412fe9c8c1029cadc0d191ccad222f">segmentedScan4</a> (T *d_odata, const T *d_idata, const unsigned int *d_iflags, unsigned int numElements, T *d_blockSums=0, unsigned int *d_blockFlags=0, unsigned int *d_blockIndices=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main segmented scan kernel.  <a href="#gaf2412fe9c8c1029cadc0d191ccad222f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Sparse Matrix-Vector multiply Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , bool isFullBlock&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gadc255d86178e5e591c3f2d2e8d5f564b">sparseMatrixVectorFetchAndMultiply</a> (unsigned int *d_flags, T *d_prod, const T *d_A, const T *d_x, const unsigned int *d_indx, unsigned int numNZElts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch and multiply kernel.  <a href="#gadc255d86178e5e591c3f2d2e8d5f564b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga650782aef0e14c36782f5c24cd96a8dd">sparseMatrixVectorSetFlags</a> (unsigned int *d_flags, const unsigned int *d_rowindx, unsigned int numRows)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Flags kernel.  <a href="#ga650782aef0e14c36782f5c24cd96a8dd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga01e289bd29d24bfc8e96dd853668900d">yGather</a> (T *d_y, const T *d_prod, const unsigned int *d_rowFindx, unsigned int numRows)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather final y values kernel.  <a href="#ga01e289bd29d24bfc8e96dd853668900d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Tridiagonal functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga7d5ce381d3e5374a8d831bd7ef81c4f6">crpcrKernel</a> (T *d_a, T *d_b, T *d_c, T *d_d, T *d_x, unsigned int systemSizeOriginal, unsigned int iterations)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid CR-PCR Tridiagonal linear system solver (CRPCR)  <a href="#ga7d5ce381d3e5374a8d831bd7ef81c4f6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Vector Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp63f22eef98a4e7ae7df3cf1d55988889"></a> CUDA kernel methods for basic operations on vectors. </p>
</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga97c40c1ecc9e0fac1dea5e0bc82873f2">vectorAddConstant</a> (T *d_vector, T constant, int n, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant value to all values in the input d_vector.  <a href="#ga97c40c1ecc9e0fac1dea5e0bc82873f2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gae01a2f4db216ff09317d622dfece364f">vectorAddUniform</a> (T *d_vector, const T *d_uniforms, int numElements, int blockOffset, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to each data element of an array.  <a href="#gae01a2f4db216ff09317d622dfece364f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab9d85a99903057488b0b4e33abed0fc8"></a><!-- doxytag: member="cudpp_kernel::vectorAddUniform2" ref="gab9d85a99903057488b0b4e33abed0fc8" args="(T *g_data, T *uniforms, int n, int eltsPerBlock)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorAddUniform2</b> (T *g_data, T *uniforms, int n, int eltsPerBlock)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Oper , int elementsPerThread, bool fullBlocks&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gadd9d043392f4f45cfb05aee36b63cbe1">vectorAddUniform4</a> (T *d_vector, const T *d_uniforms, int numElements, int vectorRowPitch, int uniformRowPitch, int blockOffset, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to each data element of an array (vec4 version)  <a href="#gadd9d043392f4f45cfb05aee36b63cbe1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#ga0db4319e840ddb75cc7d62847ad29638">vectorAddVector</a> (T *d_vectorA, const T *d_vectorB, int numElements, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds together two vectors.  <a href="#ga0db4319e840ddb75cc7d62847ad29638"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Oper , bool isLastBlockFull&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gabaab0ae2dd48171163c6458416029202">vectorSegmentedAddUniform4</a> (T *d_vector, const T *d_uniforms, const unsigned int *d_maxIndices, unsigned int numElements, int blockOffset, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to data elements of an array (vec4 version)  <a href="#gabaab0ae2dd48171163c6458416029202"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Oper , bool isLastBlockFull&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__kernel.html#gaedce93ab6c42b2bbd3d7985f39cbdd8e">vectorSegmentedAddUniformToRight4</a> (T *d_vector, const T *d_uniforms, const unsigned int *d_minIndices, unsigned int numElements, int blockOffset, int baseIndex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uniform value to data elements of an array (vec4 version)  <a href="#gaedce93ab6c42b2bbd3d7985f39cbdd8e"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The CUDPP Kernel-Level API contains functions that run on the GPU device across a grid of Cooperative Thread Array (CTA, aka Thread Block). These kernels are declared <code>__global__</code> so that they must be invoked from host (CPU) code. They generally invoke GPU <code>__device__</code> routines in the CUDPP <a class="el" href="group__cudpp__cta.html">CTA-Level API</a>. Kernel-Level API functions are used by CUDPP <a class="el" href="group__cudpp__app.html">Application-Level</a> functions to implement their functionality. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga02aca9cfcac6799d445c857626e7d317"></a><!-- doxytag: member="compact_kernel.cuh::compactData" ref="ga02aca9cfcac6799d445c857626e7d317" args="(T *d_out, size_t *d_numValidElements, const unsigned int *d_indices, const unsigned int *d_isValid, const T *d_in, unsigned int numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool isBackward&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void compactData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consolidate non-null elements - for each non-null element in <em>d_in</em> write it to <em>d_out</em>, in the position specified by <em>d_isValid</em>. Called by <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output array of compacted values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>The number of elements in d_in with valid flags set to 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_indices</td><td>Positions where non-null elements will go in d_out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isValid</td><td>Flags indicating valid (1) and invalid (0) elements. Only valid elements will be copied to <em>d_out</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The length of the <em>d_in</em> in elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa002e725192c3ac452f6c3168de2895a"></a><!-- doxytag: member="radixsort_kernel.cuh::flipFloats" ref="gaa002e725192c3ac452f6c3168de2895a" args="(uint *values, uint numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void flipFloats </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does special binary arithmetic before sorting floats. </p>
<p>Uses floatFlip function to flip bits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Values to be manipulated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numValues</td><td>Number of values to be flipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga359f23566212946fc94d7a61c9e4dfd3"></a><!-- doxytag: member="radixsort_kernel.cuh::unflipFloats" ref="ga359f23566212946fc94d7a61c9e4dfd3" args="(uint *values, uint numValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void unflipFloats </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Undoes the flips from flipFloats. </p>
<p>Uses floatUnflip function to unflip bits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Values to be manipulated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numValues</td><td>Number of values to be unflipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1c7394659289d6123e477c7b5b3a9e8b"></a><!-- doxytag: member="radixsort_kernel.cuh::radixSortSingleWarp" ref="ga1c7394659289d6123e477c7b5b3a9e8b" args="(uint *keys, uint *values, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool flip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortSingleWarp </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimization for sorts of WARP_SIZE or fewer elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab4b5a78a353c90d1698b9b7321fa8c9d"></a><!-- doxytag: member="radixsort_kernel.cuh::radixSortSingleWarpKeysOnly" ref="gab4b5a78a353c90d1698b9b7321fa8c9d" args="(uint *keys, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool flip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortSingleWarpKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimization for sorts of WARP_SIZE or fewer elements. Keys-Only version. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements to be sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2cf5bfc2844ebb31e5859f7ef28cb975"></a><!-- doxytag: member="radixsort_kernel.cuh::radixSortBlocks" ref="ga2cf5bfc2844ebb31e5859f7ef28cb975" args="(uint4 *keysOut, uint4 *valuesOut, uint4 *keysIn, uint4 *valuesIn, uint numElements, uint totalBlocks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortBlocks </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>valuesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>valuesIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements </p>
<p>The radix sort is done in two stages. This stage calls radixSortBlock on each block independently, sorting on the basis of bits (startbit) -&gt; (startbit + nbits)</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "flip" is used to only compile in the float flip code when float keys are used. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">keysOut</td><td>Output of sorted keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">valuesOut</td><td>Output of associated values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keysIn</td><td>Input of unsorted keys in GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valuesIn</td><td>Input of associated input values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>The number of blocks of data to sort </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98fa842d18a6f9d366c1853ee8458426"></a><!-- doxytag: member="radixsort_kernel.cuh::findRadixOffsets" ref="ga98fa842d18a6f9d366c1853ee8458426" args="(uint2 *keys, uint *counters, uint *blockOffsets, uint numElements, uint totalBlocks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint startbit, bool fullBlocks, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void findRadixOffsets </td>
          <td>(</td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>counters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>blockOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the number of keys of each radix in each block stores offset. </p>
<p>Given an array with blocks sorted according to a 4-bit radix group, each block counts the number of keys that fall into each radix in the group, and finds the starting offset of each radix in the block. It then writes the radix counts to the counters array, and the starting offsets to the blockOffsets array.</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Input keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counters</td><td>Radix count for each block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">blockOffsets</td><td>The offset address for each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of blocks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga326b66a44772c53ef1657289c511252d"></a><!-- doxytag: member="radixsort_kernel.cuh::reorderData" ref="ga326b66a44772c53ef1657289c511252d" args="(uint *outKeys, uint *outValues, uint2 *keys, uint2 *values, uint *blockOffsets, uint *offsets, uint *sizes, uint numElements, uint totalBlocks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void reorderData </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>outKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>outValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>blockOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorders data in the global array. </p>
<p>reorderData shuffles data in the array globally after the radix offsets have been found. On compute version 1.1 and earlier GPUs, this code depends on SORT_CTA_SIZE being 16 * number of radices (i.e. 16 * 2^nbits).</p>
<p>On compute version 1.1 GPUs ("manualCoalesce=true") this function ensures that all writes are coalesced using extra work in the kernel. On later GPUs coalescing rules have been relaxed, so this extra overhead hurts performance. On these GPUs we set manualCoalesce=false and directly store the results.</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outKeys</td><td>Output of sorted keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outValues</td><td>Output of associated values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Input of unsorted keys in GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>Input of associated input values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffsets</td><td>The offset address for each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Address of each radix within each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>Number of elements in a block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of data blocks to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Args that are const below should be prototyped as const </dd></dl>

</div>
</div>
<a class="anchor" id="ga5266ebf2bb30d8419cea059b1435d475"></a><!-- doxytag: member="radixsort_kernel.cuh::radixSortBlocksKeysOnly" ref="ga5266ebf2bb30d8419cea059b1435d475" args="(uint4 *keysOut, uint4 *keysIn, uint numElements, uint totalBlocks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit, bool fullBlocks, bool flip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void radixSortBlocksKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>keysIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts all blocks of data independently in shared memory. Each thread block (CTA) sorts one block of 4*CTA_SIZE elements. </p>
<p>The radix sort is done in two stages. This stage calls radixSortBlock on each block independently, sorting on the basis of bits (startbit) -&gt; (startbit + nbits)</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "flip" is used to only compile in the float flip code when float keys are used. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">keysOut</td><td>Output of sorted keys GPU main memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keysIn</td><td>Input of unsorted keys in GPU main memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of blocks to sort </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac8b6736ae3fa13bb852245f054cbd4eb"></a><!-- doxytag: member="radixsort_kernel.cuh::reorderDataKeysOnly" ref="gac8b6736ae3fa13bb852245f054cbd4eb" args="(uint *outKeys, uint2 *keys, uint *blockOffsets, uint *offsets, uint *sizes, uint numElements, uint totalBlocks)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint startbit, bool fullBlocks, bool manualCoalesce, bool unflip, bool loop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void reorderDataKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>outKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint2 *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>blockOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>totalBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorders data in the global array. </p>
<p>reorderDataKeysOnly shuffles data in the array globally after the radix offsets have been found. On compute version 1.1 and earlier GPUs, this code depends on SORT_CTA_SIZE being 16 * number of radices (i.e. 16 * 2^nbits).</p>
<p>On compute version 1.1 GPUs ("manualCoalesce=true") this function ensures that all writes are coalesced using extra work in the kernel. On later GPUs coalescing rules have been relaxed, so this extra overhead hurts performance. On these GPUs we set manualCoalesce=false and directly store the results.</p>
<p>Template parameters are used to generate efficient code for various special cases For example, we have to handle arrays that are a multiple of the block size (fullBlocks) differently than arrays that are not. "loop" is used when persistent CTAs are used.</p>
<p>By persistent CTAs we mean that we launch only as many thread blocks as can be resident in the GPU and no more, rather than launching as many threads as we have elements. Persistent CTAs loop over blocks of elements until all work is complete. This can be faster in some cases. In our tests it is faster for large sorts (and the threshold is higher on compute version 1.1 and earlier GPUs than it is on compute version 1.2 GPUs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outKeys</td><td>Output result of <a class="el" href="group__cudpp__kernel.html#gac8b6736ae3fa13bb852245f054cbd4eb" title="Reorders data in the global array.">reorderDataKeysOnly()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Keys to be reordered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffsets</td><td>Start offset for each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Offset of each radix within each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>Number of elements in a block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Total number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">totalBlocks</td><td>Total number of blocks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa69e40f48791d63cdd66d101a22f6a4a"></a><!-- doxytag: member="rand_kernel.cuh::gen_randMD5" ref="gaa69e40f48791d63cdd66d101a22f6a4a" args="(uint4 *d_out, size_t numElements, unsigned int seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void gen_randMD5 </td>
          <td>(</td>
          <td class="paramtype">uint4 *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main MD5 generation algorithm. </p>
<p>This function runs the MD5 hashing random number generator. It generates MD5 hashes, and uses the output as randomized bits. To repeatedly call this function, always call <a class="el" href="group__public_interface.html#ga9120af9942d2553d2f376ede0f7079dd" title="Sets the seed used for rand.">cudppRandSeed()</a> first to set a new seed or else the output may be the same due to the deterministic nature of hashes. gen_randMD5 generates 128 random bits per thread. Therefore, the parameter <em>d_out</em> is expected to be an array of type uint4 with <em>numElements</em> indicies.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>the output array of type uint4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>the number of elements in <em>d_out</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>the random seed used to vary the output</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rand__app_8cu.html#aa6aa7195d99a4d1c79c444b95b1d2a92" title="Launches the MD5 Random number generator kernel.">launchRandMD5Kernel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab64eb250a1594485b1b05a3c1458797d"></a><!-- doxytag: member="reduce_kernel.cuh::reduce" ref="gab64eb250a1594485b1b05a3c1458797d" args="(T *odata, const T *idata, unsigned int n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Oper , unsigned int blockSize, bool nIsPow2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void reduce </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>odata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main reduction kernel. </p>
<p>This reduction kernel adds multiple elements per thread sequentially, and then the threads work together to produce a block sum in shared memory. The code is optimized using warp-synchronous programming to eliminate unnecessary barrier synchronization. Performing sequential work in each thread before performing the log(N) parallel summation reduces the overall cost of the algorithm while keeping the work complexity O(n) and the step complexity O(log n). (Brent's Theorem optimization)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">odata</td><td>The output data pointer. Each block writes a single output element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idata</td><td>The input data pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements to be reduced. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga68b0aa93e22b1b3fc622ed8d86bc4310"></a><!-- doxytag: member="scan_kernel.cuh::scan4" ref="ga68b0aa93e22b1b3fc622ed8d86bc4310" args="(T *d_out, const T *d_in, T *d_blockSums, int numElements, unsigned int dataRowPitch, unsigned int blockSumRowPitch)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void scan4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_blockSums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dataRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>blockSumRowPitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main scan kernel. </p>
<p>This __global__ device function performs one level of a multiblock scan on an arbitrary-dimensioned array in <em>d_in</em>, returning the result in <em>d_out</em> (which may point to the same array). The same function may be used for single or multi-row scans. To perform a multirow scan, pass the width of each row of the input row (in elements) in <em>dataRowPitch</em>, and the width of the rows of <em>d_blockSums</em> (in elements) in <em>blockSumRowPitch</em>, and invoke with a thread block grid with height greater than 1.</p>
<p>This function peforms one level of a recursive, multiblock scan. At the app level, this function is called by cudppScan and cudppMultiScan and used in combination with <a class="el" href="group__cudpp__kernel.html#gadd9d043392f4f45cfb05aee36b63cbe1" title="Add a uniform value to each data element of an array (vec4 version)">vectorAddUniform4()</a> to produce a complete scan.</p>
<p>Template parameter <em>T</em> is the datatype of the array to be scanned. Template parameter <em>traits</em> is the <a class="el" href="class_scan_traits.html" title="Template class containing compile-time parameters to the scan functions.">ScanTraits</a> struct containing compile-time options for the scan, such as whether it is forward or backward, exclusive or inclusive, multi- or single-row, etc.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output (scanned) array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>The array of per-block sums </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataRowPitch</td><td>The width of each row of <em>d_in</em> in elements (for multi-row scans) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSumRowPitch</td><td>The with of each row of <em>d_blockSums</em> in elements (for multi-row scans) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf2412fe9c8c1029cadc0d191ccad222f"></a><!-- doxytag: member="segmented_scan_kernel.cuh::segmentedScan4" ref="gaf2412fe9c8c1029cadc0d191ccad222f" args="(T *d_odata, const T *d_idata, const unsigned int *d_iflags, unsigned int numElements, T *d_blockSums=0, unsigned int *d_blockFlags=0, unsigned int *d_blockIndices=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void segmentedScan4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_odata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_iflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_blockSums</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_blockFlags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_blockIndices</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main segmented scan kernel. </p>
<p>This __global__ device function performs one level of a multiblock segmented scan on an one-dimensioned array in <em>d_idata</em>, returning the result in <em>d_odata</em> (which may point to the same array).</p>
<p>This function performs one level of a recursive, multiblock scan. At the app level, this function is called by cudppSegmentedScan and used in combination with either <a class="el" href="group__cudpp__kernel.html#gabaab0ae2dd48171163c6458416029202" title="Add a uniform value to data elements of an array (vec4 version)">vectorSegmentedAddUniform4()</a> (forward) or <a class="el" href="group__cudpp__kernel.html#gaedce93ab6c42b2bbd3d7985f39cbdd8e" title="Add a uniform value to data elements of an array (vec4 version)">vectorSegmentedAddUniformToRight4()</a> (backward) to produce a complete segmented scan.</p>
<p>Template parameter <em>T</em> is the datatype of the array to be scanned. Template parameter <em>traits</em> is the <a class="el" href="class_segmented_scan_traits.html" title="Template class containing compile-time parameters to the segmented scan functions.">SegmentedScanTraits</a> struct containing compile-time options for the segmented scan, such as whether it is forward or backward, inclusive or exclusive, etc.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_odata</td><td>The output (scanned) array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_idata</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_iflags</td><td>The input array of flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>The array of per-block sums </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockFlags</td><td>The array of per-block OR-reduction of flags </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockIndices</td><td>The array of per-block min-reduction of indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc255d86178e5e591c3f2d2e8d5f564b"></a><!-- doxytag: member="spmvmult_kernel.cuh::sparseMatrixVectorFetchAndMultiply" ref="gadc255d86178e5e591c3f2d2e8d5f564b" args="(unsigned int *d_flags, T *d_prod, const T *d_A, const T *d_x, const unsigned int *d_indx, unsigned int numNZElts)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool isFullBlock&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void sparseMatrixVectorFetchAndMultiply </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numNZElts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch and multiply kernel. </p>
<p>This __global__ device function takes an element from the vector d_A, finds its column in d_indx and multiplies the element from d_A with its corresponding (that is having the same row) element in d_x and stores the resulting product in d_prod. It also sets all the elements of d_flags to 0.</p>
<p>Template parameter <em>T</em> is the datatype of the matrix A and x.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_flags</td><td>The output flags array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_prod</td><td>The output products array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_A</td><td>The input matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_x</td><td>The input array x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_indx</td><td>The input array of column indices for each element in A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numNZElts</td><td>The number of non-zero elements in matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga650782aef0e14c36782f5c24cd96a8dd"></a><!-- doxytag: member="spmvmult_kernel.cuh::sparseMatrixVectorSetFlags" ref="ga650782aef0e14c36782f5c24cd96a8dd" args="(unsigned int *d_flags, const unsigned int *d_rowindx, unsigned int numRows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__global__ void sparseMatrixVectorSetFlags </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>d_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_rowindx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Flags kernel. </p>
<p>This __global__ device function takes an element from the vector d_rowindx, and sets the corresponding position in d_flags to 1</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_flags</td><td>The output flags array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_rowindx</td><td>The starting index of each row in the "flattened" version of matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows in matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga01e289bd29d24bfc8e96dd853668900d"></a><!-- doxytag: member="spmvmult_kernel.cuh::yGather" ref="ga01e289bd29d24bfc8e96dd853668900d" args="(T *d_y, const T *d_prod, const unsigned int *d_rowFindx, unsigned int numRows)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void yGather </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_prod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_rowFindx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gather final y values kernel. </p>
<p>This __global__ device function takes an element from the vector d_rowFindx, which for each row gives the index of the last element of that row, reads the corresponding position in d_prod and write it in d_y</p>
<p>Template parameter <em>T</em> is the datatype of the matrix A and x.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_y</td><td>The output result array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_prod</td><td>The input products array (which now contains sums for each row) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_rowFindx</td><td>The starting index of each row in the "flattened" version of matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows in matrix A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7d5ce381d3e5374a8d831bd7ef81c4f6"></a><!-- doxytag: member="tridiagonal_kernel.cuh::crpcrKernel" ref="ga7d5ce381d3e5374a8d831bd7ef81c4f6" args="(T *d_a, T *d_b, T *d_c, T *d_d, T *d_x, unsigned int systemSizeOriginal, unsigned int iterations)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void crpcrKernel </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>systemSizeOriginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hybrid CR-PCR Tridiagonal linear system solver (CRPCR) </p>
<p>This kernel solves a tridiagonal linear system using a hybrid CR-PCR algorithm. The solver first reduces the system size using cyclic reduction, then solves the intermediate system using parallel cyclic reduction to reduce shared memory bank conflicts and algorithmic steps, and finally switches back to cyclic reduction to solve all unknowns.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_x</td><td>Solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_a</td><td>Lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_b</td><td>Main diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_c</td><td>Upper diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_d</td><td>Right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemSizeOriginal</td><td>The size of each system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td>The computed number of PCR iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga97c40c1ecc9e0fac1dea5e0bc82873f2"></a><!-- doxytag: member="vector_kernel.cuh::vectorAddConstant" ref="ga97c40c1ecc9e0fac1dea5e0bc82873f2" args="(T *d_vector, T constant, int n, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddConstant </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>constant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a constant value to all values in the input d_vector. </p>
<p>Each thread adds two pairs of elements. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Test this function -- it is currently not yet used.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_vector</td><td>The array of elements to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constant</td><td>The constant value to be added to elements of <em>d_vector</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements in the d_vector to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>An optional offset to the beginning of the elements in the input array to be processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae01a2f4db216ff09317d622dfece364f"></a><!-- doxytag: member="vector_kernel.cuh::vectorAddUniform" ref="gae01a2f4db216ff09317d622dfece364f" args="(T *d_vector, const T *d_uniforms, int numElements, int blockOffset, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddUniform </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a uniform value to each data element of an array. </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to all values "owned" by the CTA in <em>d_vector</em>. Each thread adds two pairs of values.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadd9d043392f4f45cfb05aee36b63cbe1"></a><!-- doxytag: member="vector_kernel.cuh::vectorAddUniform4" ref="gadd9d043392f4f45cfb05aee36b63cbe1" args="(T *d_vector, const T *d_uniforms, int numElements, int vectorRowPitch, int uniformRowPitch, int blockOffset, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Oper , int elementsPerThread, bool fullBlocks&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddUniform4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vectorRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>uniformRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a uniform value to each data element of an array (vec4 version) </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to all values "owned" by the CTA in <em>d_vector</em>. Each thread adds the uniform value to eight values in <em>d_vector</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vectorRowPitch</td><td>For 2D arrays, the pitch (in elements) of the rows of <em>d_vector</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uniformRowPitch</td><td>For 2D arrays, the pitch (in elements) of the rows of <em>d_uniforms</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0db4319e840ddb75cc7d62847ad29638"></a><!-- doxytag: member="vector_kernel.cuh::vectorAddVector" ref="ga0db4319e840ddb75cc7d62847ad29638" args="(T *d_vectorA, const T *d_vectorB, int numElements, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorAddVector </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vectorA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_vectorB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds together two vectors. </p>
<p>Each thread adds two pairs of elements. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Test this function -- it is currently not yet used.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vectorA</td><td>The left operand array and the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_vectorB</td><td>The right operand array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the vectors to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>An optional offset to the beginning of the elements in the input arrays to be processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabaab0ae2dd48171163c6458416029202"></a><!-- doxytag: member="vector_kernel.cuh::vectorSegmentedAddUniform4" ref="gabaab0ae2dd48171163c6458416029202" args="(T *d_vector, const T *d_uniforms, const unsigned int *d_maxIndices, unsigned int numElements, int blockOffset, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Oper , bool isLastBlockFull&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorSegmentedAddUniform4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_maxIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a uniform value to data elements of an array (vec4 version) </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to values "owned" by the CTA in <em>d_vector</em>. The uniform value is added to only those values "owned" by the CTA which have an index less than d_maxIndex. If d_maxIndex for that CTA is UINT_MAX it adds the uniform to all values "owned" by the CTA. Each thread adds the uniform value to eight values in <em>d_vector</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_maxIndices</td><td>The array of maximum indices (one per CTA). This is index upto which the uniform would be added. If this is UINT_MAX the uniform is added to all elements of the CTA. This index is 1-based. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaedce93ab6c42b2bbd3d7985f39cbdd8e"></a><!-- doxytag: member="vector_kernel.cuh::vectorSegmentedAddUniformToRight4" ref="gaedce93ab6c42b2bbd3d7985f39cbdd8e" args="(T *d_vector, const T *d_uniforms, const unsigned int *d_minIndices, unsigned int numElements, int blockOffset, int baseIndex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Oper , bool isLastBlockFull&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void vectorSegmentedAddUniformToRight4 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_uniforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_minIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baseIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a uniform value to data elements of an array (vec4 version) </p>
<p>This function reads one value per CTA from <em>d_uniforms</em> into shared memory and adds that value to values "owned" by the CTA in <em>d_vector</em>. The uniform value is added to only those values "owned" by the CTA which have an index greater than d_minIndex. If d_minIndex for that CTA is 0 it adds the uniform to all values "owned" by the CTA. Each thread adds the uniform value to eight values in <em>d_vector</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vector</td><td>The d_vector whose values will have the uniform added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_uniforms</td><td>The array of uniform values (one per CTA) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_minIndices</td><td>The array of minimum indices (one per CTA). The uniform is added to the right of this index (that is, to every index that is greater than this index). If this is 0, the uniform is added to all elements of the CTA. This index is 1-based to prevent overloading of what 0 means. In our case it means absence of a flag. But if the first element of a CTA has flag the index will also be 0. Hence we use 1-based indices so the index is 1 in the latter case. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in <em>d_vector</em> to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockOffset</td><td>an optional offset to the beginning of this block's data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseIndex</td><td>an optional offset to the beginning of the array within <em>d_vector</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Mar 8 2013 for CUDPP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
